<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Scapewatch Waypoint Generator v4.0</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Courier New', monospace;
            background-color: #1a1a1a;
            color: #fff;
            padding: 20px;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
        }

        h1 {
            color: #f39c12;
            margin-bottom: 20px;
            text-align: center;
        }

        .controls {
            display: flex;
            gap: 10px;
            margin-bottom: 20px;
            justify-content: center;
        }

        button {
            padding: 10px 20px;
            background-color: #f39c12;
            color: #000;
            border: none;
            border-radius: 4px;
            font-weight: bold;
            cursor: pointer;
            font-size: 14px;
        }

        button:hover {
            background-color: #e67e22;
        }

        button:disabled {
            background-color: #555;
            cursor: not-allowed;
        }

        .progress-container {
            background-color: #2a2a2a;
            padding: 20px;
            border-radius: 8px;
            margin-bottom: 20px;
        }

        .progress-bar {
            width: 100%;
            height: 30px;
            background-color: #333;
            border-radius: 15px;
            overflow: hidden;
            margin-bottom: 10px;
        }

        .progress-fill {
            height: 100%;
            background-color: #f39c12;
            transition: width 0.3s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            color: #000;
            font-weight: bold;
        }

        .progress-text {
            text-align: center;
            color: #aaa;
            font-size: 14px;
            margin-bottom: 5px;
        }

        .progress-detail {
            text-align: center;
            color: #3498db;
            font-size: 12px;
            font-style: italic;
            min-height: 16px;
        }

        .stats-row {
            display: flex;
            justify-content: space-around;
            background-color: #2a2a2a;
            padding: 10px;
            border-radius: 8px;
            margin-bottom: 20px;
            font-size: 14px;
        }

        .stat-inline {
            color: #aaa;
        }

        .stat-inline span {
            color: #f39c12;
            font-weight: bold;
        }

        .console {
            background-color: #000;
            border: 2px solid #444;
            border-radius: 8px;
            padding: 15px;
            height: 500px;
            overflow-y: auto;
            font-size: 12px;
            line-height: 1.4;
        }

        .console-entry {
            margin-bottom: 2px;
        }

        .error {
            color: #e74c3c;
            font-weight: bold;
        }

        .success {
            color: #2ecc71;
        }

        .warning {
            color: #f39c12;
        }

        .info {
            color: #3498db;
        }

        .dim {
            color: #666;
        }

        .highlight {
            color: #e67e22;
            font-weight: bold;
        }

        .results {
            margin-top: 20px;
            padding: 20px;
            background-color: #2a2a2a;
            border-radius: 8px;
            display: none;
        }

        .results h2 {
            color: #f39c12;
            margin-bottom: 10px;
        }

        .stats {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 10px;
            margin-bottom: 20px;
        }

        .stat-item {
            background-color: #333;
            padding: 10px;
            border-radius: 4px;
        }

        .stat-label {
            color: #888;
            font-size: 12px;
        }

        .stat-value {
            color: #f39c12;
            font-size: 18px;
            font-weight: bold;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>üõ§Ô∏è Scapewatch Waypoint Generator v4.0 üõ§Ô∏è</h1>
        
        <div class="controls">
            <button id="startBtn">Generate Waypoints</button>
            <button id="exportBtn" disabled>Export to Clipboard</button>
            <button id="downloadBtn" disabled>Download JSON</button>
        </div>

        <div class="progress-container">
            <div class="progress-bar">
                <div id="progressFill" class="progress-fill" style="width: 0%">0%</div>
            </div>
            <div id="progressText" class="progress-text">Ready to start...</div>
            <div id="progressDetail" class="progress-detail"></div>
        </div>

        <div class="stats-row" id="liveStats" style="display: none;">
            <div class="stat-inline">Nodes: <span id="liveNodesProcessed">0</span>/<span id="liveTotalNodes">0</span></div>
            <div class="stat-inline">Paths Generated: <span id="livePathsGenerated">0</span></div>
            <div class="stat-inline">Total Waypoints: <span id="liveTotalWaypoints">0</span></div>
            <div class="stat-inline">Time: <span id="liveTime">0s</span></div>
        </div>

        <div class="console" id="console"></div>

        <div class="results" id="results">
            <h2>Waypoint Generation Complete!</h2>
            <div class="stats">
                <div class="stat-item">
                    <div class="stat-label">Total Nodes</div>
                    <div class="stat-value" id="totalNodes">0</div>
                </div>
                <div class="stat-item">
                    <div class="stat-label">Banks Found</div>
                    <div class="stat-value" id="banksFound">0</div>
                </div>
                <div class="stat-item">
                    <div class="stat-label">Node‚ÜíBank Paths</div>
                    <div class="stat-value" id="nodePaths">0</div>
                </div>
                <div class="stat-item">
                    <div class="stat-label">Bank‚ÜíBank Paths</div>
                    <div class="stat-value" id="bankPaths">0</div>
                </div>
                <div class="stat-item">
                    <div class="stat-label">Total Waypoints</div>
                    <div class="stat-value" id="totalWaypoints">0</div>
                </div>
                <div class="stat-item">
                    <div class="stat-label">Processing Time</div>
                    <div class="stat-value" id="processingTime">0s</div>
                </div>
            </div>
        </div>
    </div>

    <script>
        // ==================== ERROR CAPTURE ====================
        const originalConsoleError = console.error;
        const originalConsoleWarn = console.warn;
        
        console.error = function(...args) {
            originalConsoleError.apply(console, args);
            logConsole('CONSOLE ERROR: ' + args.join(' '), 'error');
        };
        
        console.warn = function(...args) {
            originalConsoleWarn.apply(console, args);
            logConsole('CONSOLE WARN: ' + args.join(' '), 'warning');
        };
        
        window.addEventListener('error', function(e) {
            logConsole(`UNCAUGHT ERROR: ${e.message} at ${e.filename}:${e.lineno}:${e.colno}`, 'error');
        });
        
        window.addEventListener('unhandledrejection', function(e) {
            logConsole(`UNHANDLED PROMISE REJECTION: ${e.reason}`, 'error');
        });

        // ==================== COLLISION SYSTEM (EXACT COPY FROM GAME) ====================
        class CollisionSystem {
            constructor() {
                this.canvas = document.createElement('canvas');
                this.ctx = this.canvas.getContext('2d');
                this.imageData = null;
                this.width = 0;
                this.height = 0;
                this.initialized = false;
            }

            async initialize(imageUrl) {
                logConsole('Loading collision map from: ' + imageUrl, 'dim');
                
                return new Promise((resolve, reject) => {
                    const img = new Image();
                    img.crossOrigin = 'anonymous';
                    
                    img.onload = () => {
                        try {
                            this.width = img.width;
                            this.height = img.height;
                            this.canvas.width = this.width;
                            this.canvas.height = this.height;
                            
                            this.ctx.drawImage(img, 0, 0);
                            this.imageData = this.ctx.getImageData(0, 0, this.width, this.height);
                            
                            this.initialized = true;
                            logConsole(`Collision map loaded: ${this.width}x${this.height}`, 'success');
                            resolve();
                        } catch (error) {
                            logConsole('Error processing collision map: ' + error.message, 'error');
                            reject(error);
                        }
                    };
                    
                    img.onerror = (error) => {
                        logConsole('Failed to load collision map: ' + error, 'error');
                        reject(new Error('Failed to load collision map'));
                    };
                    
                    img.src = imageUrl;
                });
            }

            isWalkable(x, y) {
                if (!this.initialized) return false;
                
                x = Math.round(x);
                y = Math.round(y);
                
                if (x < 0 || y < 0 || x >= this.width || y >= this.height) {
                    return false;
                }
                
                const index = (y * this.width + x) * 4;
                const alpha = this.imageData.data[index + 3];
                
                return alpha === 0;
            }

            isLineOfSight(x1, y1, x2, y2) {
                const dx = Math.abs(x2 - x1);
                const dy = Math.abs(y2 - y1);
                const sx = x1 < x2 ? 1 : -1;
                const sy = y1 < y2 ? 1 : -1;
                let err = dx - dy;
                
                let x = Math.round(x1);
                let y = Math.round(y1);
                
                while (x !== Math.round(x2) || y !== Math.round(y2)) {
                    if (!this.isWalkable(x, y)) {
                        return false;
                    }
                    
                    const e2 = 2 * err;
                    if (e2 > -dy) {
                        err -= dy;
                        x += sx;
                    }
                    if (e2 < dx) {
                        err += dx;
                        y += sy;
                    }
                }
                
                return this.isWalkable(Math.round(x2), Math.round(y2));
            }

            getWalkableNeighbors(x, y) {
                const neighbors = [];
                
                const directions = [
                    { x: 0, y: -1 },  // North
                    { x: 1, y: -1 },  // Northeast
                    { x: 1, y: 0 },   // East
                    { x: 1, y: 1 },   // Southeast
                    { x: 0, y: 1 },   // South
                    { x: -1, y: 1 },  // Southwest
                    { x: -1, y: 0 },  // West
                    { x: -1, y: -1 }  // Northwest
                ];
                
                for (const dir of directions) {
                    const nx = x + dir.x;
                    const ny = y + dir.y;
                    
                    if (this.isWalkable(nx, ny)) {
                        if (dir.x !== 0 && dir.y !== 0) {
                            if (this.isWalkable(x + dir.x, y) && this.isWalkable(x, y + dir.y)) {
                                neighbors.push({ x: nx, y: ny });
                            }
                        } else {
                            neighbors.push({ x: nx, y: ny });
                        }
                    }
                }
                
                return neighbors;
            }
        }

        // ==================== PRIORITY QUEUE FOR A* ====================
        class PriorityQueue {
            constructor() {
                this.elements = [];
            }

            enqueue(element, priority) {
                this.elements.push({ element, priority });
                this.elements.sort((a, b) => a.priority - b.priority);
            }

            dequeue() {
                return this.elements.shift().element;
            }

            isEmpty() {
                return this.elements.length === 0;
            }

            contains(element) {
                return this.elements.some(item => 
                    item.element.x === element.x && item.element.y === element.y
                );
            }
        }

        // ==================== PATHFINDING (EXACT COPY FROM GAME) ====================
        class Pathfinding {
            constructor(collisionSystem) {
                this.collision = collisionSystem;
            }

            findPath(startX, startY, endX, endY) {
                if (!this.collision.initialized) {
                    return null;
                }

                const start = { x: Math.floor(startX) + 0.5, y: Math.floor(startY) + 0.5 };
                const end = { x: Math.floor(endX) + 0.5, y: Math.floor(endY) + 0.5 };

                if (!this.collision.isWalkable(Math.floor(start.x), Math.floor(start.y))) {
                    return null;
                }
                if (!this.collision.isWalkable(Math.floor(end.x), Math.floor(end.y))) {
                    return null;
                }

                if (this.collision.isLineOfSight(Math.floor(start.x), Math.floor(start.y), Math.floor(end.x), Math.floor(end.y))) {
                    return [start, end];
                }

                const openSet = new PriorityQueue();
                const closedSet = new Set();
                const cameFrom = new Map();
                const gScore = new Map();
                const fScore = new Map();

                const startKey = `${start.x},${start.y}`;
                gScore.set(startKey, 0);
                fScore.set(startKey, this.heuristic(start, end));
                openSet.enqueue(start, fScore.get(startKey));

                while (!openSet.isEmpty()) {
                    const current = openSet.dequeue();
                    const currentKey = `${current.x},${current.y}`;

                    if (current.x === end.x && current.y === end.y) {
                        return this.reconstructPath(cameFrom, current);
                    }

                    closedSet.add(currentKey);

                    const neighbors = this.collision.getWalkableNeighbors(Math.floor(current.x), Math.floor(current.y));
                    
                    for (const neighbor of neighbors) {
                        neighbor.x = neighbor.x + 0.5;
                        neighbor.y = neighbor.y + 0.5;
                        const neighborKey = `${neighbor.x},${neighbor.y}`;
                        
                        if (closedSet.has(neighborKey)) {
                            continue;
                        }

                        const isDiagonal = Math.abs(neighbor.x - current.x) === 1 && Math.abs(neighbor.y - current.y) === 1;
                        const moveCost = isDiagonal ? Math.sqrt(2) : 1;
                        const tentativeGScore = gScore.get(currentKey) + moveCost;

                        if (!gScore.has(neighborKey) || tentativeGScore < gScore.get(neighborKey)) {
                            cameFrom.set(neighborKey, current);
                            gScore.set(neighborKey, tentativeGScore);
                            fScore.set(neighborKey, tentativeGScore + this.heuristic(neighbor, end));

                            if (!openSet.contains(neighbor)) {
                                openSet.enqueue(neighbor, fScore.get(neighborKey));
                            }
                        }
                    }
                }

                return null;
            }

            heuristic(a, b) {
                return Math.sqrt(Math.pow(b.x - a.x, 2) + Math.pow(b.y - a.y, 2));
            }

            reconstructPath(cameFrom, current) {
                const path = [current];
                let currentKey = `${current.x},${current.y}`;

                while (cameFrom.has(currentKey)) {
                    current = cameFrom.get(currentKey);
                    path.unshift(current);
                    currentKey = `${current.x},${current.y}`;
                }
                
                const centeredPath = path.map(point => ({
                    x: Math.floor(point.x) + 0.5,
                    y: Math.floor(point.y) + 0.5
                }));

                return this.smoothPath(centeredPath);
            }

            smoothPath(path) {
                if (path.length < 3) return path;

                const smoothed = [path[0]];
                let current = 0;

                while (current < path.length - 1) {
                    let farthest = current + 1;
                    
                    for (let i = current + 2; i < path.length; i++) {
                        if (this.collision.isLineOfSight(
                            Math.floor(path[current].x), 
                            Math.floor(path[current].y), 
                            Math.floor(path[i].x), 
                            Math.floor(path[i].y)
                        )) {
                            farthest = i;
                        } else {
                            break;
                        }
                    }

                    smoothed.push(path[farthest]);
                    current = farthest;
                }

                return smoothed;
            }

            getPathDistance(path) {
                if (!path || path.length < 2) return Infinity;
                
                let distance = 0;
                for (let i = 1; i < path.length; i++) {
                    const dx = path[i].x - path[i-1].x;
                    const dy = path[i].y - path[i-1].y;
                    distance += Math.sqrt(dx * dx + dy * dy);
                }
                return distance;
            }
        }

        // ==================== HELPER FUNCTIONS ====================
        function findNearestWalkablePosition(collision, x, y, maxRadius = 5) {
            if (collision.isWalkable(x, y)) {
                return { x, y, adjusted: false };
            }

            for (let radius = 1; radius <= maxRadius; radius++) {
                const steps = radius * 8;
                for (let i = 0; i < steps; i++) {
                    const angle = (i / steps) * Math.PI * 2;
                    const checkX = Math.round(x + Math.cos(angle) * radius);
                    const checkY = Math.round(y + Math.sin(angle) * radius);
                    
                    if (collision.isWalkable(checkX, checkY)) {
                        return { x: checkX, y: checkY, adjusted: true };
                    }
                }
            }

            return { x, y, adjusted: false, failed: true };
        }

        // Async delay to prevent browser hanging
        function asyncDelay(ms = 0) {
            return new Promise(resolve => setTimeout(resolve, ms));
        }

        // ==================== MAIN TOOL LOGIC ====================
        let collision = null;
        let pathfinding = null;
        let nodesData = null;
        let startTime = null;
        let nodeAdjustments = {};
        let globalStats = {
            pathsGenerated: 0,
            nodesProcessed: 0,
            totalWaypoints: 0
        };

        function logConsole(message, type = 'normal') {
            const consoleDiv = document.getElementById('console');
            if (!consoleDiv) return;
            
            const entry = document.createElement('div');
            entry.className = `console-entry ${type}`;
            const timestamp = new Date().toLocaleTimeString();
            entry.textContent = `[${timestamp}] ${message}`;
            consoleDiv.appendChild(entry);
            consoleDiv.scrollTop = consoleDiv.scrollHeight;
        }

        function updateProgress(current, total, message) {
            const percentage = Math.round((current / total) * 100);
            const progressFill = document.getElementById('progressFill');
            const progressText = document.getElementById('progressText');
            
            if (progressFill) {
                progressFill.style.width = `${percentage}%`;
                progressFill.textContent = `${percentage}%`;
            }
            if (progressText) {
                progressText.textContent = message;
            }
        }

        function updateProgressDetail(detail) {
            const progressDetail = document.getElementById('progressDetail');
            if (progressDetail) {
                progressDetail.textContent = detail;
            }
        }

        function updateLiveStats() {
            document.getElementById('liveNodesProcessed').textContent = globalStats.nodesProcessed;
            document.getElementById('livePathsGenerated').textContent = globalStats.pathsGenerated;
            document.getElementById('liveTotalWaypoints').textContent = globalStats.totalWaypoints;
            
            const elapsed = ((Date.now() - startTime) / 1000).toFixed(1);
            document.getElementById('liveTime').textContent = `${elapsed}s`;
        }

        async function loadNodesData() {
            const url = 'https://puzzle-drops.github.io/ScapewatchRC/data/nodes.json';
            logConsole('Fetching nodes.json from: ' + url, 'dim');
            
            try {
                const response = await fetch(url);
                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }
                
                const text = await response.text();
                const data = JSON.parse(text);
                nodesData = data;
                
                const nodeCount = Object.keys(data).length;
                logConsole(`Successfully parsed ${nodeCount} nodes from nodes.json`, 'success');
                
                return data;
            } catch (error) {
                logConsole(`ERROR loading nodes: ${error.message}`, 'error');
                throw error;
            }
        }

        async function generateWaypoints() {
            try {
                startTime = Date.now();
                const stats = {
                    total: 0,
                    banks: 0,
                    nodePaths: 0,
                    bankPaths: 0,
                    totalWaypoints: 0
                };

                // Reset global stats
                globalStats = {
                    pathsGenerated: 0,
                    nodesProcessed: 0,
                    totalWaypoints: 0
                };

                if (!nodesData) {
                    throw new Error('No nodes data loaded!');
                }

                const nodeEntries = Object.entries(nodesData);
                stats.total = nodeEntries.length;
                
                // Show live stats
                document.getElementById('liveStats').style.display = 'flex';
                document.getElementById('liveTotalNodes').textContent = stats.total;
                
                logConsole(`Starting waypoint generation for ${stats.total} nodes...`, 'info');

                // Step 1: Check accessibility and find walkable positions
                logConsole('', 'normal');
                logConsole('=== PHASE 1: CHECKING NODE ACCESSIBILITY ===', 'highlight');
                const accessibleNodes = [];
                const accessibleBanks = [];
                const inaccessibleNodes = [];
                nodeAdjustments = {};

                let checkCount = 0;
                for (const [nodeId, node] of nodeEntries) {
                    checkCount++;
                    
                    if (checkCount % 5 === 0) {
                        updateProgress(checkCount, nodeEntries.length * 3, // multiply by 3 for 3 phases
                                     `Phase 1: Checking accessibility (${checkCount}/${nodeEntries.length})`);
                        updateProgressDetail(`Currently checking: ${nodeId}`);
                        await asyncDelay(1);
                    }
                    
                    const x = Math.floor(node.position.x);
                    const y = Math.floor(node.position.y);
                    
                    const walkablePos = findNearestWalkablePosition(collision, x, y, 3);
                    
                    if (!walkablePos.failed) {
                        nodeAdjustments[nodeId] = {
                            x: walkablePos.x,
                            y: walkablePos.y,
                            adjusted: walkablePos.adjusted
                        };
                        
                        if (walkablePos.adjusted) {
                            logConsole(`  ‚Üí Adjusted ${nodeId} from (${x}, ${y}) to (${walkablePos.x}, ${walkablePos.y})`, 'dim');
                        }
                        
                        accessibleNodes.push({ id: nodeId, node });
                        if (node.type === 'bank') {
                            accessibleBanks.push({ id: nodeId, node });
                            stats.banks++;
                            logConsole(`‚úì BANK: ${nodeId} is accessible`, 'success');
                        }
                    } else {
                        inaccessibleNodes.push({ id: nodeId, node });
                        logConsole(`‚úó ${nodeId} is INACCESSIBLE at (${x}, ${y})`, 'warning');
                    }
                }

                logConsole(`Phase 1 Complete: Found ${accessibleBanks.length} banks`, 'success');
                await asyncDelay(100);

                // Step 2: Generate node to bank paths
                logConsole('', 'normal');
                logConsole('=== PHASE 2: GENERATING NODE‚ÜíBANK PATHS ===', 'highlight');
                logConsole(`Generating paths from ${accessibleNodes.length} nodes to their nearest banks...`, 'info');
                
                let processedCount = 0;
                for (const { id: nodeId, node } of accessibleNodes) {
                    processedCount++;
                    globalStats.nodesProcessed = processedCount;
                    
                    const progressBase = nodeEntries.length;
                    updateProgress(progressBase + processedCount, nodeEntries.length * 3,
                                  `Phase 2: Generating node‚Üíbank paths (${processedCount}/${accessibleNodes.length})`);
                    
                    if (node.type === 'bank') {
                        // Banks don't need paths to themselves
                        node.nearestBank = nodeId;
                        node.nearestBankDistance = 0;
                        // No pathToBank needed for banks
                        updateProgressDetail(`${nodeId}: Is a bank (no path needed)`);
                        updateLiveStats();
                        await asyncDelay(1);
                    } else {
                        updateProgressDetail(`${nodeId}: Finding path to nearest bank...`);
                        
                        const nodePos = nodeAdjustments[nodeId];
                        let nearestBank = null;
                        let shortestDistance = Infinity;
                        let bestPath = null;

                        // Test each bank
                        for (const { id: bankId, node: bankNode } of accessibleBanks) {
                            const bankPos = nodeAdjustments[bankId];
                            
                            const path = pathfinding.findPath(
                                nodePos.x, nodePos.y,
                                bankPos.x, bankPos.y
                            );

                            if (path) {
                                const distance = pathfinding.getPathDistance(path);
                                
                                if (distance < shortestDistance) {
                                    shortestDistance = distance;
                                    nearestBank = bankId;
                                    bestPath = path;
                                }
                            }
                        }

                        if (nearestBank && bestPath) {
                            node.nearestBank = nearestBank;
                            node.nearestBankDistance = Math.round(shortestDistance);
                            node.pathToBank = bestPath; // Store the waypoints!
                            
                            globalStats.pathsGenerated++;
                            globalStats.totalWaypoints += bestPath.length;
                            stats.nodePaths++;
                            
                            logConsole(`‚úì ${nodeId} ‚Üí ${nearestBank} (${Math.round(shortestDistance)} pixels, ${bestPath.length} waypoints)`, 'dim');
                        } else {
                            node.nearestBank = null;
                            node.nearestBankDistance = null;
                            node.pathToBank = null;
                            logConsole(`‚úó ${nodeId} ‚Üí NO REACHABLE BANK!`, 'error');
                        }
                        
                        updateLiveStats();
                        await asyncDelay(1);
                    }
                }

                logConsole(`Phase 2 Complete: Generated ${stats.nodePaths} node‚Üíbank paths`, 'success');
                await asyncDelay(100);

                // Step 3: Generate bank to bank paths
                logConsole('', 'normal');
                logConsole('=== PHASE 3: GENERATING BANK‚ÜíBANK PATHS ===', 'highlight');
                logConsole(`Generating paths between ${accessibleBanks.length} banks...`, 'info');
                
                let bankProcessedCount = 0;
                const totalBankPairs = accessibleBanks.length * (accessibleBanks.length - 1);
                
                for (const { id: bank1Id, node: bank1Node } of accessibleBanks) {
                    // Initialize pathsToOtherBanks object
                    if (!bank1Node.pathsToOtherBanks) {
                        bank1Node.pathsToOtherBanks = {};
                    }
                    
                    const bank1Pos = nodeAdjustments[bank1Id];
                    
                    for (const { id: bank2Id, node: bank2Node } of accessibleBanks) {
                        if (bank1Id === bank2Id) continue; // Skip self
                        
                        bankProcessedCount++;
                        const progressBase = nodeEntries.length * 2;
                        updateProgress(progressBase + bankProcessedCount, nodeEntries.length * 3,
                                      `Phase 3: Generating bank‚Üíbank paths (${bankProcessedCount}/${totalBankPairs})`);
                        updateProgressDetail(`${bank1Id} ‚Üí ${bank2Id}`);
                        
                        const bank2Pos = nodeAdjustments[bank2Id];
                        
                        const path = pathfinding.findPath(
                            bank1Pos.x, bank1Pos.y,
                            bank2Pos.x, bank2Pos.y
                        );
                        
                        if (path) {
                            bank1Node.pathsToOtherBanks[bank2Id] = path;
                            
                            globalStats.pathsGenerated++;
                            globalStats.totalWaypoints += path.length;
                            stats.bankPaths++;
                            
                            const distance = pathfinding.getPathDistance(path);
                            logConsole(`‚úì ${bank1Id} ‚Üí ${bank2Id} (${Math.round(distance)} pixels, ${path.length} waypoints)`, 'dim');
                        } else {
                            logConsole(`‚úó ${bank1Id} ‚Üí ${bank2Id}: NO PATH FOUND!`, 'error');
                        }
                        
                        updateLiveStats();
                        await asyncDelay(1);
                    }
                }

                logConsole(`Phase 3 Complete: Generated ${stats.bankPaths} bank‚Üíbank paths`, 'success');

                // Step 4: Handle inaccessible nodes
                logConsole('', 'normal');
                logConsole('=== PHASE 4: HANDLING INACCESSIBLE NODES ===', 'highlight');
                for (const { id: nodeId, node } of inaccessibleNodes) {
                    node.nearestBank = null;
                    node.nearestBankDistance = null;
                    node.pathToBank = null;
                }
                logConsole(`Set ${inaccessibleNodes.length} inaccessible nodes to null`, 'info');

                updateProgress(100, 100, 'Waypoint generation complete!');
                updateProgressDetail('');
                
                const endTime = Date.now();
                const processingTime = ((endTime - startTime) / 1000).toFixed(1);

                // Calculate file size estimate
                const jsonStr = JSON.stringify(nodesData);
                const sizeKB = Math.round(jsonStr.length / 1024);

                // Update final stats
                stats.totalWaypoints = globalStats.totalWaypoints;
                document.getElementById('totalNodes').textContent = stats.total;
                document.getElementById('banksFound').textContent = stats.banks;
                document.getElementById('nodePaths').textContent = stats.nodePaths;
                document.getElementById('bankPaths').textContent = stats.bankPaths;
                document.getElementById('totalWaypoints').textContent = stats.totalWaypoints;
                document.getElementById('processingTime').textContent = `${processingTime}s`;

                updateLiveStats();

                logConsole('', 'normal');
                logConsole('=== WAYPOINT GENERATION COMPLETE ===', 'highlight');
                logConsole(`Generated ${stats.nodePaths} node‚Üíbank paths`, 'info');
                logConsole(`Generated ${stats.bankPaths} bank‚Üíbank paths`, 'info');
                logConsole(`Total waypoints: ${stats.totalWaypoints}`, 'info');
                logConsole(`Estimated file size: ${sizeKB} KB`, 'info');

                // Show results
                document.getElementById('results').style.display = 'block';
                document.getElementById('exportBtn').disabled = false;
                document.getElementById('downloadBtn').disabled = false;
                
            } catch (error) {
                logConsole(`ERROR in generateWaypoints: ${error.message}`, 'error');
                logConsole(`Stack trace: ${error.stack}`, 'error');
                throw error;
            }
        }

        async function exportToClipboard() {
            try {
                const jsonStr = JSON.stringify(nodesData, null, 2);
                await navigator.clipboard.writeText(jsonStr);
                logConsole('JSON copied to clipboard!', 'success');
                alert('JSON copied to clipboard!');
            } catch (error) {
                logConsole(`Failed to copy to clipboard: ${error.message}`, 'error');
                const textArea = document.createElement('textarea');
                textArea.value = JSON.stringify(nodesData, null, 2);
                document.body.appendChild(textArea);
                textArea.select();
                document.execCommand('copy');
                document.body.removeChild(textArea);
                logConsole('JSON copied to clipboard (fallback method)!', 'success');
            }
        }

        function downloadJSON() {
            try {
                const jsonStr = JSON.stringify(nodesData, null, 2);
                const blob = new Blob([jsonStr], { type: 'application/json' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = 'nodes_with_waypoints.json';
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
                logConsole('JSON downloaded as nodes_with_waypoints.json', 'success');
            } catch (error) {
                logConsole(`Download failed: ${error.message}`, 'error');
            }
        }

        async function startGeneration() {
            const startBtn = document.getElementById('startBtn');
            startBtn.disabled = true;
            
            try {
                logConsole('Starting Waypoint Generator v4.0...', 'highlight');
                logConsole('This tool generates waypoint paths and stores them directly in nodes.json', 'info');
                
                collision = new CollisionSystem();
                await collision.initialize('https://puzzle-drops.github.io/ScapewatchRC/assets/collision-map.png');
                
                pathfinding = new Pathfinding(collision);
                logConsole('Pathfinding system initialized', 'success');
                
                logConsole('Loading nodes data...', 'info');
                await loadNodesData();
                
                logConsole('Beginning waypoint generation...', 'info');
                await generateWaypoints();
                
            } catch (error) {
                logConsole(`FATAL ERROR: ${error.message}`, 'error');
                logConsole(`Stack trace: ${error.stack}`, 'error');
                startBtn.disabled = false;
            }
        }

        // Event listeners
        document.getElementById('startBtn').addEventListener('click', startGeneration);
        document.getElementById('exportBtn').addEventListener('click', exportToClipboard);
        document.getElementById('downloadBtn').addEventListener('click', downloadJSON);
        
        // Initial log
        logConsole('Waypoint Generator v4.0 ready', 'highlight');
        logConsole('This tool will:', 'info');
        logConsole('‚Ä¢ Generate paths from each node to its nearest bank', 'info');
        logConsole('‚Ä¢ Generate paths between all banks', 'info');
        logConsole('‚Ä¢ Store waypoints directly in the nodes data', 'info');
        logConsole('Click "Generate Waypoints" to begin', 'success');
    </script>
</body>
</html>
