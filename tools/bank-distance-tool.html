<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Scapewatch Waypoint Generator v4.3</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Courier New', monospace;
            background-color: #1a1a1a;
            color: #fff;
            padding: 20px;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
        }

        h1 {
            color: #f39c12;
            margin-bottom: 20px;
            text-align: center;
        }

        .controls {
            display: flex;
            gap: 10px;
            margin-bottom: 20px;
            justify-content: center;
            align-items: center;
        }

        button {
            padding: 10px 20px;
            background-color: #f39c12;
            color: #000;
            border: none;
            border-radius: 4px;
            font-weight: bold;
            cursor: pointer;
            font-size: 14px;
        }

        button:hover {
            background-color: #e67e22;
        }

        button:disabled {
            background-color: #555;
            cursor: not-allowed;
        }

        .node-selector {
            display: none;
            background-color: #2a2a2a;
            padding: 20px;
            border-radius: 8px;
            margin-bottom: 20px;
        }

        .selector-header {
            margin-bottom: 15px;
        }

        .selector-title {
            color: #f39c12;
            font-size: 16px;
            font-weight: bold;
            margin-bottom: 10px;
        }

        .selector-controls {
            display: flex;
            flex-direction: column;
            gap: 5px;
        }

        .selector-control-row {
            display: flex;
            gap: 10px;
            justify-content: center;
        }

        .selector-controls button {
            padding: 5px 15px;
            font-size: 12px;
        }

        .type-separator {
            width: 100%;
            padding: 8px;
            background-color: #333;
            color: #f39c12;
            font-weight: bold;
            text-align: center;
            margin: 5px 0;
            border-radius: 3px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .type-separator-title {
            flex: 1;
            text-align: center;
        }

        .type-separator-controls {
            display: flex;
            gap: 5px;
        }

        .type-separator-controls button {
            padding: 3px 10px;
            font-size: 11px;
            background-color: #555;
        }

        .type-separator-controls button:hover {
            background-color: #666;
        }

        .node-list {
            max-height: 400px;
            overflow-y: auto;
            background-color: #1a1a1a;
            border: 2px solid #444;
            border-radius: 4px;
            padding: 10px;
        }

        .node-item {
            display: flex;
            align-items: center;
            padding: 5px;
            margin-bottom: 2px;
            background-color: #222;
            border-radius: 3px;
        }

        .node-item:hover {
            background-color: #333;
        }

        .node-checkbox {
            margin-right: 10px;
        }

        .node-label {
            flex: 1;
            display: flex;
            justify-content: space-between;
            cursor: pointer;
        }

        .node-type {
            color: #888;
            font-size: 12px;
        }

        .node-type.bank {
            color: #2ecc71;
        }

        .node-type.multi-skill {
            color: #9b59b6;
        }

        .selection-stats {
            margin-top: 10px;
            text-align: center;
            color: #aaa;
            font-size: 14px;
        }

        .progress-container {
            background-color: #2a2a2a;
            padding: 20px;
            border-radius: 8px;
            margin-bottom: 20px;
        }

        .progress-bar {
            width: 100%;
            height: 30px;
            background-color: #333;
            border-radius: 15px;
            overflow: hidden;
            margin-bottom: 10px;
        }

        .progress-fill {
            height: 100%;
            background-color: #f39c12;
            transition: width 0.3s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            color: #000;
            font-weight: bold;
        }

        .progress-text {
            text-align: center;
            color: #aaa;
            font-size: 14px;
            margin-bottom: 5px;
        }

        .progress-detail {
            text-align: center;
            color: #3498db;
            font-size: 12px;
            font-style: italic;
            min-height: 16px;
        }

        .stats-row {
            display: flex;
            justify-content: space-around;
            background-color: #2a2a2a;
            padding: 10px;
            border-radius: 8px;
            margin-bottom: 20px;
            font-size: 14px;
        }

        .stat-inline {
            color: #aaa;
        }

        .stat-inline span {
            color: #f39c12;
            font-weight: bold;
        }

        .console {
            background-color: #000;
            border: 2px solid #444;
            border-radius: 8px;
            padding: 15px;
            height: 500px;
            overflow-y: auto;
            font-size: 12px;
            line-height: 1.4;
        }

        .console-entry {
            margin-bottom: 2px;
        }

        .error {
            color: #e74c3c;
            font-weight: bold;
        }

        .success {
            color: #2ecc71;
        }

        .warning {
            color: #f39c12;
        }

        .info {
            color: #3498db;
        }

        .dim {
            color: #666;
        }

        .highlight {
            color: #e67e22;
            font-weight: bold;
        }

        .results {
            margin-top: 20px;
            padding: 20px;
            background-color: #2a2a2a;
            border-radius: 8px;
            display: none;
        }

        .results h2 {
            color: #f39c12;
            margin-bottom: 10px;
        }

        .stats {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 10px;
            margin-bottom: 20px;
        }

        .stat-item {
            background-color: #333;
            padding: 10px;
            border-radius: 4px;
        }

        .stat-label {
            color: #888;
            font-size: 12px;
        }

        .stat-value {
            color: #f39c12;
            font-size: 18px;
            font-weight: bold;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>üõ§Ô∏è Scapewatch Waypoint Generator v4.3 üõ§Ô∏è</h1>
        
        <div class="controls">
            <button id="loadBtn">Load Nodes</button>
            <button id="generateBtn" disabled>Generate Waypoints for Selected</button>
            <button id="exportBtn" disabled>Export to Clipboard</button>
            <button id="downloadBtn" disabled>Download JSON</button>
            <label style="display: flex; align-items: center; gap: 5px; color: #aaa; font-size: 14px;">
                <input type="checkbox" id="includeBankPaths" checked>
                Include Bank‚ÜíBank Paths
            </label>
        </div>

        <div class="node-selector" id="nodeSelector">
            <div class="selector-header">
                <div class="selector-title">Select Nodes to Process</div>
                <div class="selector-controls">
                    <div class="selector-control-row">
                        <button id="selectAllBtn">Select All</button>
                        <button id="deselectAllBtn">Deselect All</button>
                    </div>
                    <div class="selector-control-row">
                        <button id="selectAllBanksBtn">Select All Banks</button>
                        <button id="deselectAllBanksBtn">Deselect All Banks</button>
                    </div>
                    <div class="selector-control-row">
                        <button id="selectAllSkillsBtn">Select All Skills</button>
                        <button id="deselectAllSkillsBtn">Deselect All Skills</button>
                    </div>
                    <div class="selector-control-row">
                        <button id="selectAllQuestsBtn">Select All Quests</button>
                        <button id="deselectAllQuestsBtn">Deselect All Quests</button>
                    </div>
                </div>
            </div>
            <div class="node-list" id="nodeList"></div>
            <div class="selection-stats" id="selectionStats">0 nodes selected</div>
        </div>

        <div class="progress-container">
            <div class="progress-bar">
                <div id="progressFill" class="progress-fill" style="width: 0%">0%</div>
            </div>
            <div id="progressText" class="progress-text">Ready to start...</div>
            <div id="progressDetail" class="progress-detail"></div>
        </div>

        <div class="stats-row" id="liveStats" style="display: none;">
            <div class="stat-inline">Nodes: <span id="liveNodesProcessed">0</span>/<span id="liveTotalNodes">0</span></div>
            <div class="stat-inline">Paths Generated: <span id="livePathsGenerated">0</span></div>
            <div class="stat-inline">Total Waypoints: <span id="liveTotalWaypoints">0</span></div>
            <div class="stat-inline">Time: <span id="liveTime">0s</span></div>
        </div>

        <div class="console" id="console"></div>

        <div class="results" id="results">
            <h2>Waypoint Generation Complete!</h2>
            <div class="stats">
                <div class="stat-item">
                    <div class="stat-label">Total Nodes</div>
                    <div class="stat-value" id="totalNodes">0</div>
                </div>
                <div class="stat-item">
                    <div class="stat-label">Banks Found</div>
                    <div class="stat-value" id="banksFound">0</div>
                </div>
                <div class="stat-item">
                    <div class="stat-label">Node‚ÜíBank Paths</div>
                    <div class="stat-value" id="nodePaths">0</div>
                </div>
                <div class="stat-item">
                    <div class="stat-label">Bank‚ÜíBank Paths</div>
                    <div class="stat-value" id="bankPaths">0</div>
                </div>
                <div class="stat-item">
                    <div class="stat-label">Total Waypoints</div>
                    <div class="stat-value" id="totalWaypoints">0</div>
                </div>
                <div class="stat-item">
                    <div class="stat-label">Processing Time</div>
                    <div class="stat-value" id="processingTime">0s</div>
                </div>
            </div>
        </div>
    </div>

    <script>
        // ==================== ERROR CAPTURE ====================
        const originalConsoleError = console.error;
        const originalConsoleWarn = console.warn;
        
        console.error = function(...args) {
            originalConsoleError.apply(console, args);
            logConsole('CONSOLE ERROR: ' + args.join(' '), 'error');
        };
        
        console.warn = function(...args) {
            originalConsoleWarn.apply(console, args);
            logConsole('CONSOLE WARN: ' + args.join(' '), 'warning');
        };
        
        window.addEventListener('error', function(e) {
            logConsole(`UNCAUGHT ERROR: ${e.message} at ${e.filename}:${e.lineno}:${e.colno}`, 'error');
        });
        
        window.addEventListener('unhandledrejection', function(e) {
            logConsole(`UNHANDLED PROMISE REJECTION: ${e.reason}`, 'error');
        });

        // ==================== COLLISION SYSTEM (EXACT COPY FROM GAME) ====================
        class CollisionSystem {
            constructor() {
                this.canvas = document.createElement('canvas');
                this.ctx = this.canvas.getContext('2d');
                this.imageData = null;
                this.width = 0;
                this.height = 0;
                this.initialized = false;
            }

            async initialize(imageUrl) {
                logConsole('Loading collision map from: ' + imageUrl, 'dim');
                
                return new Promise((resolve, reject) => {
                    const img = new Image();
                    img.crossOrigin = 'anonymous';
                    
                    img.onload = () => {
                        try {
                            this.width = img.width;
                            this.height = img.height;
                            this.canvas.width = this.width;
                            this.canvas.height = this.height;
                            
                            this.ctx.drawImage(img, 0, 0);
                            this.imageData = this.ctx.getImageData(0, 0, this.width, this.height);
                            
                            this.initialized = true;
                            logConsole(`Collision map loaded: ${this.width}x${this.height}`, 'success');
                            resolve();
                        } catch (error) {
                            logConsole('Error processing collision map: ' + error.message, 'error');
                            reject(error);
                        }
                    };
                    
                    img.onerror = (error) => {
                        logConsole('Failed to load collision map: ' + error, 'error');
                        reject(new Error('Failed to load collision map'));
                    };
                    
                    img.src = imageUrl;
                });
            }

            isWalkable(x, y) {
                if (!this.initialized) return false;
                
                x = Math.round(x);
                y = Math.round(y);
                
                if (x < 0 || y < 0 || x >= this.width || y >= this.height) {
                    return false;
                }
                
                const index = (y * this.width + x) * 4;
                const alpha = this.imageData.data[index + 3];
                
                return alpha === 0;
            }

            isLineOfSight(x1, y1, x2, y2) {
                const dx = Math.abs(x2 - x1);
                const dy = Math.abs(y2 - y1);
                const sx = x1 < x2 ? 1 : -1;
                const sy = y1 < y2 ? 1 : -1;
                let err = dx - dy;
                
                let x = Math.round(x1);
                let y = Math.round(y1);
                
                while (x !== Math.round(x2) || y !== Math.round(y2)) {
                    if (!this.isWalkable(x, y)) {
                        return false;
                    }
                    
                    const e2 = 2 * err;
                    if (e2 > -dy) {
                        err -= dy;
                        x += sx;
                    }
                    if (e2 < dx) {
                        err += dx;
                        y += sy;
                    }
                }
                
                return this.isWalkable(Math.round(x2), Math.round(y2));
            }

            getWalkableNeighbors(x, y) {
                const neighbors = [];
                
                const directions = [
                    { x: 0, y: -1 },  // North
                    { x: 1, y: -1 },  // Northeast
                    { x: 1, y: 0 },   // East
                    { x: 1, y: 1 },   // Southeast
                    { x: 0, y: 1 },   // South
                    { x: -1, y: 1 },  // Southwest
                    { x: -1, y: 0 },  // West
                    { x: -1, y: -1 }  // Northwest
                ];
                
                for (const dir of directions) {
                    const nx = x + dir.x;
                    const ny = y + dir.y;
                    
                    if (this.isWalkable(nx, ny)) {
                        if (dir.x !== 0 && dir.y !== 0) {
                            if (this.isWalkable(x + dir.x, y) && this.isWalkable(x, y + dir.y)) {
                                neighbors.push({ x: nx, y: ny });
                            }
                        } else {
                            neighbors.push({ x: nx, y: ny });
                        }
                    }
                }
                
                return neighbors;
            }
        }

        // ==================== PRIORITY QUEUE FOR A* ====================
        class PriorityQueue {
            constructor() {
                this.elements = [];
            }

            enqueue(element, priority) {
                this.elements.push({ element, priority });
                this.elements.sort((a, b) => a.priority - b.priority);
            }

            dequeue() {
                return this.elements.shift().element;
            }

            isEmpty() {
                return this.elements.length === 0;
            }

            contains(element) {
                return this.elements.some(item => 
                    item.element.x === element.x && item.element.y === element.y
                );
            }
        }

        // ==================== PATHFINDING (EXACT COPY FROM GAME) ====================
        class Pathfinding {
            constructor(collisionSystem) {
                this.collision = collisionSystem;
            }

            findPath(startX, startY, endX, endY) {
                if (!this.collision.initialized) {
                    return null;
                }

                const start = { x: Math.floor(startX) + 0.5, y: Math.floor(startY) + 0.5 };
                const end = { x: Math.floor(endX) + 0.5, y: Math.floor(endY) + 0.5 };

                if (!this.collision.isWalkable(Math.floor(start.x), Math.floor(start.y))) {
                    return null;
                }
                if (!this.collision.isWalkable(Math.floor(end.x), Math.floor(end.y))) {
                    return null;
                }

                if (this.collision.isLineOfSight(Math.floor(start.x), Math.floor(start.y), Math.floor(end.x), Math.floor(end.y))) {
                    return [start, end];
                }

                const openSet = new PriorityQueue();
                const closedSet = new Set();
                const cameFrom = new Map();
                const gScore = new Map();
                const fScore = new Map();

                const startKey = `${start.x},${start.y}`;
                gScore.set(startKey, 0);
                fScore.set(startKey, this.heuristic(start, end));
                openSet.enqueue(start, fScore.get(startKey));

                while (!openSet.isEmpty()) {
                    const current = openSet.dequeue();
                    const currentKey = `${current.x},${current.y}`;

                    if (current.x === end.x && current.y === end.y) {
                        return this.reconstructPath(cameFrom, current);
                    }

                    closedSet.add(currentKey);

                    const neighbors = this.collision.getWalkableNeighbors(Math.floor(current.x), Math.floor(current.y));
                    
                    for (const neighbor of neighbors) {
                        neighbor.x = neighbor.x + 0.5;
                        neighbor.y = neighbor.y + 0.5;
                        const neighborKey = `${neighbor.x},${neighbor.y}`;
                        
                        if (closedSet.has(neighborKey)) {
                            continue;
                        }

                        const isDiagonal = Math.abs(neighbor.x - current.x) === 1 && Math.abs(neighbor.y - current.y) === 1;
                        const moveCost = isDiagonal ? Math.sqrt(2) : 1;
                        const tentativeGScore = gScore.get(currentKey) + moveCost;

                        if (!gScore.has(neighborKey) || tentativeGScore < gScore.get(neighborKey)) {
                            cameFrom.set(neighborKey, current);
                            gScore.set(neighborKey, tentativeGScore);
                            fScore.set(neighborKey, tentativeGScore + this.heuristic(neighbor, end));

                            if (!openSet.contains(neighbor)) {
                                openSet.enqueue(neighbor, fScore.get(neighborKey));
                            }
                        }
                    }
                }

                return null;
            }

            heuristic(a, b) {
                return Math.sqrt(Math.pow(b.x - a.x, 2) + Math.pow(b.y - a.y, 2));
            }

            reconstructPath(cameFrom, current) {
                const path = [current];
                let currentKey = `${current.x},${current.y}`;

                while (cameFrom.has(currentKey)) {
                    current = cameFrom.get(currentKey);
                    path.unshift(current);
                    currentKey = `${current.x},${current.y}`;
                }
                
                const centeredPath = path.map(point => ({
                    x: Math.floor(point.x) + 0.5,
                    y: Math.floor(point.y) + 0.5
                }));

                return this.smoothPath(centeredPath);
            }

            smoothPath(path) {
                if (path.length < 3) return path;

                const smoothed = [path[0]];
                let current = 0;

                while (current < path.length - 1) {
                    let farthest = current + 1;
                    
                    for (let i = current + 2; i < path.length; i++) {
                        if (this.collision.isLineOfSight(
                            Math.floor(path[current].x), 
                            Math.floor(path[current].y), 
                            Math.floor(path[i].x), 
                            Math.floor(path[i].y)
                        )) {
                            farthest = i;
                        } else {
                            break;
                        }
                    }

                    smoothed.push(path[farthest]);
                    current = farthest;
                }

                return smoothed;
            }

            getPathDistance(path) {
                if (!path || path.length < 2) return Infinity;
                
                let distance = 0;
                for (let i = 1; i < path.length; i++) {
                    const dx = path[i].x - path[i-1].x;
                    const dy = path[i].y - path[i-1].y;
                    distance += Math.sqrt(dx * dx + dy * dy);
                }
                return distance;
            }
        }

        // ==================== HELPER FUNCTIONS ====================
        function findNearestWalkablePosition(collision, x, y, maxRadius = 5) {
            if (collision.isWalkable(x, y)) {
                return { x, y, adjusted: false };
            }

            for (let radius = 1; radius <= maxRadius; radius++) {
                const steps = radius * 8;
                for (let i = 0; i < steps; i++) {
                    const angle = (i / steps) * Math.PI * 2;
                    const checkX = Math.round(x + Math.cos(angle) * radius);
                    const checkY = Math.round(y + Math.sin(angle) * radius);
                    
                    if (collision.isWalkable(checkX, checkY)) {
                        return { x: checkX, y: checkY, adjusted: true };
                    }
                }
            }

            return { x, y, adjusted: false, failed: true };
        }

        // Async delay to prevent browser hanging
        function asyncDelay(ms = 0) {
            return new Promise(resolve => setTimeout(resolve, ms));
        }

        // ==================== MAIN TOOL LOGIC ====================
        let collision = null;
        let pathfinding = null;
        let nodesData = null;
        let activitiesData = null;
        let selectedNodes = new Set();
        let startTime = null;
        let nodeAdjustments = {};
        let globalStats = {
            pathsGenerated: 0,
            nodesProcessed: 0,
            totalWaypoints: 0
        };

        function logConsole(message, type = 'normal') {
            const consoleDiv = document.getElementById('console');
            if (!consoleDiv) return;
            
            const entry = document.createElement('div');
            entry.className = `console-entry ${type}`;
            const timestamp = new Date().toLocaleTimeString();
            entry.textContent = `[${timestamp}] ${message}`;
            consoleDiv.appendChild(entry);
            consoleDiv.scrollTop = consoleDiv.scrollHeight;
        }

        function updateProgress(current, total, message) {
            const percentage = Math.round((current / total) * 100);
            const progressFill = document.getElementById('progressFill');
            const progressText = document.getElementById('progressText');
            
            if (progressFill) {
                progressFill.style.width = `${percentage}%`;
                progressFill.textContent = `${percentage}%`;
            }
            if (progressText) {
                progressText.textContent = message;
            }
        }

        function updateProgressDetail(detail) {
            const progressDetail = document.getElementById('progressDetail');
            if (progressDetail) {
                progressDetail.textContent = detail;
            }
        }

        function updateLiveStats() {
            document.getElementById('liveNodesProcessed').textContent = globalStats.nodesProcessed;
            document.getElementById('livePathsGenerated').textContent = globalStats.pathsGenerated;
            document.getElementById('liveTotalWaypoints').textContent = globalStats.totalWaypoints;
            
            const elapsed = ((Date.now() - startTime) / 1000).toFixed(1);
            document.getElementById('liveTime').textContent = `${elapsed}s`;
        }

        async function loadActivitiesData() {
            const url = 'https://puzzle-drops.github.io/ScapewatchRC/data/activities.json';
            logConsole('Fetching activities.json from: ' + url, 'dim');
            
            try {
                const response = await fetch(url);
                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }
                
                const text = await response.text();
                const data = JSON.parse(text);
                activitiesData = data;
                
                const activityCount = Object.keys(data).length;
                logConsole(`Successfully parsed ${activityCount} activities from activities.json`, 'success');
                
                return data;
            } catch (error) {
                logConsole(`ERROR loading activities: ${error.message}`, 'error');
                throw error;
            }
        }

        function getNodeSkills(node) {
            if (node.type === 'bank' || node.type === 'quest') {
                return [];
            }
            
            const skills = new Set();
            if (node.activities && activitiesData) {
                for (const activityId of node.activities) {
                    const activity = activitiesData[activityId];
                    if (activity && activity.skill) {
                        skills.add(activity.skill);
                    }
                }
            }
            return Array.from(skills).sort();
        }

        function categorizeAndSortNodes(nodes) {
            const categorized = {
                banks: [],
                multiSkill: [],
                bySkill: {},
                quests: []
            };
            
            Object.entries(nodes).forEach(([nodeId, node]) => {
                if (node.type === 'bank') {
                    categorized.banks.push([nodeId, node]);
                } else if (node.type === 'quest') {
                    categorized.quests.push([nodeId, node]);
                } else if (node.type === 'skill') {
                    const skills = getNodeSkills(node);
                    if (skills.length > 1) {
                        categorized.multiSkill.push([nodeId, node]);
                    } else if (skills.length === 1) {
                        const skill = skills[0];
                        if (!categorized.bySkill[skill]) {
                            categorized.bySkill[skill] = [];
                        }
                        categorized.bySkill[skill].push([nodeId, node]);
                    }
                }
            });
            
            // Sort each category alphabetically by nodeId
            categorized.banks.sort((a, b) => a[0].localeCompare(b[0]));
            categorized.multiSkill.sort((a, b) => a[0].localeCompare(b[0]));
            categorized.quests.sort((a, b) => a[0].localeCompare(b[0]));
            
            // Sort skill nodes within each skill
            Object.keys(categorized.bySkill).forEach(skill => {
                categorized.bySkill[skill].sort((a, b) => a[0].localeCompare(b[0]));
            });
            
            return categorized;
        }

        function createNodeSelector() {
            const nodeList = document.getElementById('nodeList');
            nodeList.innerHTML = '';
            
            const categorized = categorizeAndSortNodes(nodesData);
            
            // Banks
            if (categorized.banks.length > 0) {
                const separator = document.createElement('div');
                separator.className = 'type-separator';
                separator.innerHTML = `
                    <span class="type-separator-title">BANKS</span>
                    <div class="type-separator-controls">
                        <button onclick="selectAllInCategory('bank')">Select All</button>
                        <button onclick="deselectAllInCategory('bank')">Deselect All</button>
                    </div>
                `;
                nodeList.appendChild(separator);
                
                categorized.banks.forEach(([nodeId, node]) => {
                    createNodeItem(nodeList, nodeId, node, 'bank');
                });
            }
            
            // Multi-skill nodes
            if (categorized.multiSkill.length > 0) {
                const separator = document.createElement('div');
                separator.className = 'type-separator';
                separator.innerHTML = `
                    <span class="type-separator-title">MULTI-SKILL</span>
                    <div class="type-separator-controls">
                        <button onclick="selectAllInCategory('multi-skill')">Select All</button>
                        <button onclick="deselectAllInCategory('multi-skill')">Deselect All</button>
                    </div>
                `;
                nodeList.appendChild(separator);
                
                categorized.multiSkill.forEach(([nodeId, node]) => {
                    const skills = getNodeSkills(node).join(', ');
                    createNodeItem(nodeList, nodeId, node, 'multi-skill', skills);
                });
            }
            
            // Single skill nodes (sorted by skill name)
            const sortedSkills = Object.keys(categorized.bySkill).sort();
            sortedSkills.forEach(skill => {
                const separator = document.createElement('div');
                separator.className = 'type-separator';
                const displaySkill = skill.charAt(0).toUpperCase() + skill.slice(1);
                separator.innerHTML = `
                    <span class="type-separator-title">${displaySkill.toUpperCase()}</span>
                    <div class="type-separator-controls">
                        <button onclick="selectAllInCategory('skill-${skill}')">Select All</button>
                        <button onclick="deselectAllInCategory('skill-${skill}')">Deselect All</button>
                    </div>
                `;
                nodeList.appendChild(separator);
                
                categorized.bySkill[skill].forEach(([nodeId, node]) => {
                    createNodeItem(nodeList, nodeId, node, `skill-${skill}`, skill);
                });
            });
            
            // Quests
            if (categorized.quests.length > 0) {
                const separator = document.createElement('div');
                separator.className = 'type-separator';
                separator.innerHTML = `
                    <span class="type-separator-title">QUESTS</span>
                    <div class="type-separator-controls">
                        <button onclick="selectAllInCategory('quest')">Select All</button>
                        <button onclick="deselectAllInCategory('quest')">Deselect All</button>
                    </div>
                `;
                nodeList.appendChild(separator);
                
                categorized.quests.forEach(([nodeId, node]) => {
                    createNodeItem(nodeList, nodeId, node, 'quest');
                });
            }
            
            updateSelectionStats();
            document.getElementById('nodeSelector').style.display = 'block';
            document.getElementById('generateBtn').disabled = false;
        }

        function createNodeItem(container, nodeId, node, category, skillInfo = '') {
            const nodeItem = document.createElement('div');
            nodeItem.className = 'node-item';
            
            const checkbox = document.createElement('input');
            checkbox.type = 'checkbox';
            checkbox.className = 'node-checkbox';
            checkbox.id = `node-${nodeId}`;
            checkbox.dataset.category = category;
            checkbox.checked = true;
            selectedNodes.add(nodeId);
            
            const label = document.createElement('label');
            label.className = 'node-label';
            label.htmlFor = `node-${nodeId}`;
            
            const nodeName = document.createElement('span');
            nodeName.textContent = nodeId;
            
            const nodeType = document.createElement('span');
            nodeType.className = `node-type ${category === 'bank' ? 'bank' : category === 'multi-skill' ? 'multi-skill' : ''}`;
            nodeType.textContent = skillInfo ? `[${skillInfo}]` : `[${node.type}]`;
            
            label.appendChild(nodeName);
            label.appendChild(nodeType);
            
            nodeItem.appendChild(checkbox);
            nodeItem.appendChild(label);
            
            checkbox.addEventListener('change', () => {
                if (checkbox.checked) {
                    selectedNodes.add(nodeId);
                } else {
                    selectedNodes.delete(nodeId);
                }
                updateSelectionStats();
            });
            
            container.appendChild(nodeItem);
        }

        function updateSelectionStats() {
            const stats = document.getElementById('selectionStats');
            const totalNodes = Object.keys(nodesData).length;
            stats.textContent = `${selectedNodes.size} of ${totalNodes} nodes selected`;
        }

        function selectAll() {
            const checkboxes = document.querySelectorAll('.node-checkbox');
            checkboxes.forEach(checkbox => {
                checkbox.checked = true;
                const nodeId = checkbox.id.replace('node-', '');
                selectedNodes.add(nodeId);
            });
            updateSelectionStats();
        }

        function deselectAll() {
            const checkboxes = document.querySelectorAll('.node-checkbox');
            checkboxes.forEach(checkbox => {
                checkbox.checked = false;
            });
            selectedNodes.clear();
            updateSelectionStats();
        }

        function selectAllByType(type) {
            const checkboxes = document.querySelectorAll(`.node-checkbox[data-node-type="${type}"]`);
            checkboxes.forEach(checkbox => {
                checkbox.checked = true;
                const nodeId = checkbox.id.replace('node-', '');
                selectedNodes.add(nodeId);
            });
            updateSelectionStats();
        }

        function deselectAllByType(type) {
            const checkboxes = document.querySelectorAll(`.node-checkbox[data-node-type="${type}"]`);
            checkboxes.forEach(checkbox => {
                checkbox.checked = false;
                const nodeId = checkbox.id.replace('node-', '');
                selectedNodes.delete(nodeId);
            });
            updateSelectionStats();
        }

        window.selectAllInCategory = function(category) {
            const checkboxes = document.querySelectorAll(`.node-checkbox[data-category="${category}"]`);
            checkboxes.forEach(checkbox => {
                checkbox.checked = true;
                const nodeId = checkbox.id.replace('node-', '');
                selectedNodes.add(nodeId);
            });
            updateSelectionStats();
        };

        window.deselectAllInCategory = function(category) {
            const checkboxes = document.querySelectorAll(`.node-checkbox[data-category="${category}"]`);
            checkboxes.forEach(checkbox => {
                checkbox.checked = false;
                const nodeId = checkbox.id.replace('node-', '');
                selectedNodes.delete(nodeId);
            });
            updateSelectionStats();
        };

        async function loadNodesData() {
            const url = 'https://puzzle-drops.github.io/ScapewatchRC/data/nodes.json';
            logConsole('Fetching nodes.json from: ' + url, 'dim');
            
            try {
                const response = await fetch(url);
                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }
                
                const text = await response.text();
                const data = JSON.parse(text);
                nodesData = data;
                
                const nodeCount = Object.keys(data).length;
                logConsole(`Successfully parsed ${nodeCount} nodes from nodes.json`, 'success');
                
                return data;
            } catch (error) {
                logConsole(`ERROR loading nodes: ${error.message}`, 'error');
                throw error;
            }
        }

        async function generateWaypoints() {
            try {
                startTime = Date.now();
                const stats = {
                    total: 0,
                    banks: 0,
                    nodePaths: 0,
                    bankPaths: 0,
                    totalWaypoints: 0
                };

                // Reset global stats
                globalStats = {
                    pathsGenerated: 0,
                    nodesProcessed: 0,
                    totalWaypoints: 0
                };

                if (!nodesData) {
                    throw new Error('No nodes data loaded!');
                }

                // Check if we should include bank paths
                const includeBankPaths = document.getElementById('includeBankPaths').checked;
                const totalPhases = includeBankPaths ? 3 : 2; // 2 phases without bank paths, 3 with

                // Filter nodes based on selection
                const selectedNodeEntries = Object.entries(nodesData).filter(([nodeId]) => selectedNodes.has(nodeId));
                stats.total = selectedNodeEntries.length;
                
                // Show live stats
                document.getElementById('liveStats').style.display = 'flex';
                document.getElementById('liveTotalNodes').textContent = stats.total;
                
                logConsole(`Starting waypoint generation for ${stats.total} selected nodes...`, 'info');
                logConsole(`Bank‚ÜíBank paths: ${includeBankPaths ? 'ENABLED' : 'DISABLED'}`, includeBankPaths ? 'info' : 'warning');

                // Step 1: Check accessibility and find walkable positions
                logConsole('', 'normal');
                logConsole('=== PHASE 1: CHECKING NODE ACCESSIBILITY ===', 'highlight');
                const accessibleNodes = [];
                const accessibleBanks = [];
                const inaccessibleNodes = [];
                nodeAdjustments = {};

                let checkCount = 0;
                for (const [nodeId, node] of selectedNodeEntries) {
                    checkCount++;
                    
                    if (checkCount % 5 === 0) {
                        updateProgress(checkCount, selectedNodeEntries.length * totalPhases,
                                     `Phase 1: Checking accessibility (${checkCount}/${selectedNodeEntries.length})`);
                        updateProgressDetail(`Currently checking: ${nodeId}`);
                        await asyncDelay(1);
                    }
                    
                    const x = Math.floor(node.position.x);
                    const y = Math.floor(node.position.y);
                    
                    const walkablePos = findNearestWalkablePosition(collision, x, y, 3);
                    
                    if (!walkablePos.failed) {
                        nodeAdjustments[nodeId] = {
                            x: walkablePos.x,
                            y: walkablePos.y,
                            adjusted: walkablePos.adjusted
                        };
                        
                        if (walkablePos.adjusted) {
                            logConsole(`  ‚Üí Adjusted ${nodeId} from (${x}, ${y}) to (${walkablePos.x}, ${walkablePos.y})`, 'dim');
                        }
                        
                        accessibleNodes.push({ id: nodeId, node });
                        if (node.type === 'bank') {
                            accessibleBanks.push({ id: nodeId, node });
                            stats.banks++;
                            logConsole(`‚úì BANK: ${nodeId} is accessible`, 'success');
                        }
                    } else {
                        inaccessibleNodes.push({ id: nodeId, node });
                        logConsole(`‚úó ${nodeId} is INACCESSIBLE at (${x}, ${y})`, 'warning');
                    }
                }

                // Include ALL banks (even if not selected) for path calculations
                const allBanks = [];
                Object.entries(nodesData).forEach(([nodeId, node]) => {
                    if (node.type === 'bank') {
                        const x = Math.floor(node.position.x);
                        const y = Math.floor(node.position.y);
                        const walkablePos = findNearestWalkablePosition(collision, x, y, 3);
                        
                        if (!walkablePos.failed) {
                            if (!nodeAdjustments[nodeId]) {
                                nodeAdjustments[nodeId] = {
                                    x: walkablePos.x,
                                    y: walkablePos.y,
                                    adjusted: walkablePos.adjusted
                                };
                            }
                            allBanks.push({ id: nodeId, node });
                        }
                    }
                });

                logConsole(`Phase 1 Complete: Found ${accessibleBanks.length} selected banks, ${allBanks.length} total banks`, 'success');
                await asyncDelay(100);

                // Step 2: Generate node to bank paths
                logConsole('', 'normal');
                logConsole('=== PHASE 2: GENERATING NODE‚ÜíBANK PATHS ===', 'highlight');
                logConsole(`Generating paths from ${accessibleNodes.length} nodes to their nearest banks...`, 'info');
                logConsole(`Testing against ${allBanks.length} total banks in the game`, 'info');
                
                let processedCount = 0;
                for (const { id: nodeId, node } of accessibleNodes) {
                    processedCount++;
                    globalStats.nodesProcessed = processedCount;
                    
                    const progressBase = selectedNodeEntries.length;
                    updateProgress(progressBase + processedCount, selectedNodeEntries.length * totalPhases,
                                  `Phase 2: Generating node‚Üíbank paths (${processedCount}/${accessibleNodes.length})`);
                    
                    logConsole(``, 'normal');
                    logConsole(`Current Node (${processedCount}/${accessibleNodes.length}): ${nodeId}`, 'info');
                    
                    if (node.type === 'bank') {
                        // Banks don't need paths to themselves
                        node.nearestBank = nodeId;
                        node.nearestBankDistance = 0;
                        // No pathToBank needed for banks
                        updateProgressDetail(`${nodeId}: Is a bank (no path needed)`);
                        logConsole(`  ‚Üí Skipping (is a bank itself)`, 'dim');
                        updateLiveStats();
                        await asyncDelay(1);
                    } else {
                        updateProgressDetail(`${nodeId}: Starting bank search...`);
                        
                        const nodePos = nodeAdjustments[nodeId];
                        let nearestBank = null;
                        let shortestDistance = Infinity;
                        let bestPath = null;
                        let bankTestCount = 0;

                        // Calculate Euclidean distances to all banks and sort them
                        const banksWithDistance = allBanks.map(({ id: bankId, node: bankNode }) => {
                            const bankPos = nodeAdjustments[bankId];
                            const dx = bankPos.x - nodePos.x;
                            const dy = bankPos.y - nodePos.y;
                            const euclideanDistance = Math.sqrt(dx * dx + dy * dy);
                            return { id: bankId, node: bankNode, euclideanDistance };
                        });
                        
                        // Sort banks by Euclidean distance (closest first)
                        banksWithDistance.sort((a, b) => a.euclideanDistance - b.euclideanDistance);
                        
                        logConsole(`  ‚Üí Banks sorted by Euclidean distance (testing closest first)`, 'dim');
                        
                        // Test banks in order of Euclidean distance
                        for (let i = 0; i < banksWithDistance.length; i++) {
                            const { id: bankId, node: bankNode, euclideanDistance } = banksWithDistance[i];
                            bankTestCount++;
                            
                            // Check if we can skip remaining banks
                            if (shortestDistance < euclideanDistance) {
                                const skipped = banksWithDistance.length - bankTestCount;
                                logConsole(`  ‚Üí OPTIMIZATION: Current best (${Math.round(shortestDistance)}px) < next Euclidean (${Math.round(euclideanDistance)}px)`, 'warning');
                                logConsole(`  ‚Üí Skipping ${skipped} remaining banks (impossible to be closer)`, 'warning');
                                updateProgressDetail(`${nodeId}: Skipped ${skipped} banks via optimization`);
                                await asyncDelay(0);
                                break;
                            }
                            
                            // Log before testing each bank (with Euclidean distance)
                            logConsole(`  ‚Üí Testing bank ${bankTestCount}/${banksWithDistance.length}: ${bankId} (Euclidean: ${Math.round(euclideanDistance)}px)`, 'dim');
                            updateProgressDetail(`${nodeId}: Testing path to ${bankId} (${bankTestCount}/${banksWithDistance.length})`);
                            await asyncDelay(0); // Let browser update
                            
                            const bankPos = nodeAdjustments[bankId];
                            
                            const path = pathfinding.findPath(
                                nodePos.x, nodePos.y,
                                bankPos.x, bankPos.y
                            );

                            if (path) {
                                const distance = pathfinding.getPathDistance(path);
                                
                                if (distance < shortestDistance) {
                                    shortestDistance = distance;
                                    nearestBank = bankId;
                                    bestPath = path;
                                    logConsole(`    ‚úì Found path: distance=${Math.round(distance)} pixels (NEW BEST!)`, 'success');
                                } else {
                                    logConsole(`    ‚úì Found path: distance=${Math.round(distance)} pixels`, 'dim');
                                }
                            } else {
                                logConsole(`    ‚úó No path found`, 'dim');
                            }
                        }

                        if (nearestBank && bestPath) {
                            node.nearestBank = nearestBank;
                            node.nearestBankDistance = Math.round(shortestDistance);
                            node.pathToBank = bestPath; // Store the waypoints!
                            
                            globalStats.pathsGenerated++;
                            globalStats.totalWaypoints += bestPath.length;
                            stats.nodePaths++;
                            
                            logConsole(`  ‚úì RESULT: ${nodeId} ‚Üí ${nearestBank} (${Math.round(shortestDistance)} pixels, ${bestPath.length} waypoints)`, 'success');
                        } else {
                            node.nearestBank = null;
                            node.nearestBankDistance = null;
                            node.pathToBank = null;
                            logConsole(`  ‚úó RESULT: ${nodeId} ‚Üí NO REACHABLE BANK!`, 'error');
                        }
                        
                        updateLiveStats();
                        await asyncDelay(1);
                    }
                }

                logConsole(`Phase 2 Complete: Generated ${stats.nodePaths} node‚Üíbank paths`, 'success');
                await asyncDelay(100);

                // Step 3: Generate bank to bank paths (only if checkbox is checked)
                if (includeBankPaths) {
                    logConsole('', 'normal');
                    logConsole('=== PHASE 3: GENERATING BANK‚ÜíBANK PATHS (OPTIMIZED) ===', 'highlight');
                    logConsole(`Generating paths between ${accessibleBanks.length} selected banks...`, 'info');
                    
                    // Track which bank pairs have been calculated in this session
                    const calculatedPairs = new Set();
                    
                    // Calculate total unique pairs (n * (n-1) / 2)
                    const totalUniquePairs = (accessibleBanks.length * (accessibleBanks.length - 1)) / 2;
                    logConsole(`Using symmetric path optimization: ${totalUniquePairs} unique pairs instead of ${accessibleBanks.length * (accessibleBanks.length - 1)} total`, 'warning');
                    
                    let bankProcessedCount = 0;
                    let skippedByOptimization = 0;
                    
                    let bankIndex = 0;
                    for (const { id: bank1Id, node: bank1Node } of accessibleBanks) {
                        bankIndex++;
                        logConsole(``, 'normal');
                        logConsole(`Processing Bank ${bankIndex}/${accessibleBanks.length}: ${bank1Id}`, 'highlight');
                        
                        // Initialize pathsToOtherBanks object
                        if (!bank1Node.pathsToOtherBanks) {
                            bank1Node.pathsToOtherBanks = {};
                        }
                        
                        const bank1Pos = nodeAdjustments[bank1Id];
                        
                        let targetBankIndex = 0;
                        for (const { id: bank2Id, node: bank2Node } of accessibleBanks) {
                            if (bank1Id === bank2Id) continue; // Skip self
                            
                            targetBankIndex++;
                            
                            // Create a unique key for this pair (alphabetically sorted to ensure consistency)
                            const pairKey = [bank1Id, bank2Id].sort().join('->');
                            
                            // Check if we've already calculated this pair
                            if (calculatedPairs.has(pairKey)) {
                                skippedByOptimization++;
                                logConsole(`  ‚Üí Path ${targetBankIndex}: ${bank1Id} ‚Üí ${bank2Id} [SKIPPED - already calculated as ${bank2Id} ‚Üí ${bank1Id}]`, 'warning');
                                
                                // The reverse path should already exist, no need to do anything
                                updateProgressDetail(`Skipped (using reversed path): ${bank1Id} ‚Üí ${bank2Id}`);
                                continue;
                            }
                            
                            bankProcessedCount++;
                            
                            logConsole(`  ‚Üí Path ${targetBankIndex}: ${bank1Id} ‚Üí ${bank2Id} (Unique pair ${bankProcessedCount}/${totalUniquePairs})`, 'dim');
                            
                            const progressBase = selectedNodeEntries.length * 2;
                            updateProgress(progressBase + bankProcessedCount, selectedNodeEntries.length * 2 + totalUniquePairs,
                                          `Phase 3: Bank‚Üíbank paths (${bankProcessedCount}/${totalUniquePairs} unique)`);
                            updateProgressDetail(`Calculating: ${bank1Id} ‚Üí ${bank2Id}`);
                            
                            const bank2Pos = nodeAdjustments[bank2Id];
                            
                            const path = pathfinding.findPath(
                                bank1Pos.x, bank1Pos.y,
                                bank2Pos.x, bank2Pos.y
                            );
                            
                            if (path) {
                                // Store the path from bank1 to bank2
                                bank1Node.pathsToOtherBanks[bank2Id] = path;
                                
                                // Store the REVERSED path from bank2 to bank1
                                if (!bank2Node.pathsToOtherBanks) {
                                    bank2Node.pathsToOtherBanks = {};
                                }
                                const reversedPath = [...path].reverse();
                                bank2Node.pathsToOtherBanks[bank1Id] = reversedPath;
                                
                                // Mark this pair as calculated
                                calculatedPairs.add(pairKey);
                                
                                // Update stats (counting both paths)
                                globalStats.pathsGenerated += 2;
                                globalStats.totalWaypoints += path.length * 2;
                                stats.bankPaths += 2;
                                
                                const distance = pathfinding.getPathDistance(path);
                                logConsole(`    ‚úì Path found: ${Math.round(distance)} pixels, ${path.length} waypoints`, 'success');
                                logConsole(`    ‚úì Reversed path automatically stored for ${bank2Id} ‚Üí ${bank1Id}`, 'info');
                            } else {
                                // Mark as calculated even if no path found
                                calculatedPairs.add(pairKey);
                                logConsole(`    ‚úó NO PATH FOUND!`, 'error');
                            }
                            
                            updateLiveStats();
                            await asyncDelay(1);
                        }
                    }

                    logConsole(``, 'normal');
                    logConsole(`Phase 3 Complete: Generated ${stats.bankPaths} bank‚Üíbank paths`, 'success');
                    logConsole(`Optimization saved ${skippedByOptimization} redundant calculations!`, 'warning');
                } else {
                    logConsole('', 'normal');
                    logConsole('=== PHASE 3: SKIPPED (Bank‚ÜíBank paths disabled) ===', 'warning');
                }

                // Step 4: Handle inaccessible nodes
                logConsole('', 'normal');
                logConsole('=== PHASE 4: HANDLING INACCESSIBLE NODES ===', 'highlight');
                for (const { id: nodeId, node } of inaccessibleNodes) {
                    node.nearestBank = null;
                    node.nearestBankDistance = null;
                    node.pathToBank = null;
                }
                logConsole(`Set ${inaccessibleNodes.length} inaccessible nodes to null`, 'info');

                updateProgress(100, 100, 'Waypoint generation complete!');
                updateProgressDetail('');
                
                const endTime = Date.now();
                const processingTime = ((endTime - startTime) / 1000).toFixed(1);

                // Calculate file size estimate
                const jsonStr = JSON.stringify(nodesData);
                const sizeKB = Math.round(jsonStr.length / 1024);

                // Update final stats
                stats.totalWaypoints = globalStats.totalWaypoints;
                document.getElementById('totalNodes').textContent = stats.total;
                document.getElementById('banksFound').textContent = stats.banks;
                document.getElementById('nodePaths').textContent = stats.nodePaths;
                document.getElementById('bankPaths').textContent = stats.bankPaths;
                document.getElementById('totalWaypoints').textContent = stats.totalWaypoints;
                document.getElementById('processingTime').textContent = `${processingTime}s`;

                updateLiveStats();

                logConsole('', 'normal');
                logConsole('=== WAYPOINT GENERATION COMPLETE ===', 'highlight');
                logConsole(`Generated ${stats.nodePaths} node‚Üíbank paths`, 'info');
                logConsole(`Generated ${stats.bankPaths} bank‚Üíbank paths`, 'info');
                logConsole(`Total waypoints: ${stats.totalWaypoints}`, 'info');
                logConsole(`Estimated file size: ${sizeKB} KB`, 'info');

                // Show results
                document.getElementById('results').style.display = 'block';
                document.getElementById('exportBtn').disabled = false;
                document.getElementById('downloadBtn').disabled = false;
                
            } catch (error) {
                logConsole(`ERROR in generateWaypoints: ${error.message}`, 'error');
                logConsole(`Stack trace: ${error.stack}`, 'error');
                throw error;
            }
        }

        function sortNodesData(data) {
            const categorized = categorizeAndSortNodes(data);
            const sortedData = {};
            
            // Add banks first
            categorized.banks.forEach(([nodeId, node]) => {
                sortedData[nodeId] = node;
            });
            
            // Add multi-skill nodes
            categorized.multiSkill.forEach(([nodeId, node]) => {
                sortedData[nodeId] = node;
            });
            
            // Add single-skill nodes by skill (alphabetically)
            const sortedSkills = Object.keys(categorized.bySkill).sort();
            sortedSkills.forEach(skill => {
                categorized.bySkill[skill].forEach(([nodeId, node]) => {
                    sortedData[nodeId] = node;
                });
            });
            
            // Add quests last
            categorized.quests.forEach(([nodeId, node]) => {
                sortedData[nodeId] = node;
            });
            
            return sortedData;
        }

        function formatCompactJSON(data) {
            // Custom JSON formatter that puts arrays and objects on single lines
            const indent = '  ';
            
            function stringifyValue(value, depth) {
                if (value === null) return 'null';
                if (typeof value === 'undefined') return 'undefined';
                if (typeof value === 'string') return JSON.stringify(value);
                if (typeof value === 'number' || typeof value === 'boolean') return String(value);
                
                // For arrays and simple objects, put on one line
                if (Array.isArray(value)) {
                    return JSON.stringify(value);
                }
                
                // For simple objects (position, etc), put on one line
                if (typeof value === 'object') {
                    const keys = Object.keys(value);
                    // If it's a small object or specific properties we want on one line
                    if (keys.length <= 5 || keys.includes('x') || keys.includes('y')) {
                        return JSON.stringify(value);
                    }
                    
                    // For pathsToOtherBanks, format each path on one line
                    if (keys.every(k => Array.isArray(value[k]))) {
                        let result = '{';
                        const entries = Object.entries(value);
                        entries.forEach(([key, val], index) => {
                            result += '\n' + indent.repeat(depth + 1) + '"' + key + '": ' + JSON.stringify(val);
                            if (index < entries.length - 1) result += ',';
                        });
                        if (entries.length > 0) {
                            result += '\n' + indent.repeat(depth);
                        }
                        result += '}';
                        return result;
                    }
                    
                    // For node objects, format with proper indentation
                    let result = '{';
                    const entries = Object.entries(value);
                    entries.forEach(([key, val], index) => {
                        result += '\n' + indent.repeat(depth + 1) + '"' + key + '": ';
                        
                        // Format nested objects/arrays
                        if (typeof val === 'object' && val !== null && !Array.isArray(val) && 
                            !Object.keys(val).includes('x') && key !== 'pathsToOtherBanks') {
                            result += stringifyValue(val, depth + 1);
                        } else {
                            result += stringifyValue(val, depth + 1);
                        }
                        
                        if (index < entries.length - 1) result += ',';
                    });
                    if (entries.length > 0) {
                        result += '\n' + indent.repeat(depth);
                    }
                    result += '}';
                    return result;
                }
                
                return JSON.stringify(value);
            }
            
            // Start formatting the top-level object
            let result = '{';
            const entries = Object.entries(data);
            entries.forEach(([nodeId, nodeData], index) => {
                result += '\n' + indent + '"' + nodeId + '": ';
                result += stringifyValue(nodeData, 1);
                if (index < entries.length - 1) result += ',';
            });
            if (entries.length > 0) {
                result += '\n';
            }
            result += '}';
            
            return result;
        }

        async function exportToClipboard() {
            try {
                const sortedData = sortNodesData(nodesData);
                const jsonStr = formatCompactJSON(sortedData);
                await navigator.clipboard.writeText(jsonStr);
                logConsole('JSON copied to clipboard!', 'success');
                alert('JSON copied to clipboard!');
            } catch (error) {
                logConsole(`Failed to copy to clipboard: ${error.message}`, 'error');
                const sortedData = sortNodesData(nodesData);
                const textArea = document.createElement('textarea');
                textArea.value = formatCompactJSON(sortedData);
                document.body.appendChild(textArea);
                textArea.select();
                document.execCommand('copy');
                document.body.removeChild(textArea);
                logConsole('JSON copied to clipboard (fallback method)!', 'success');
            }
        }

        function downloadJSON() {
            try {
                const sortedData = sortNodesData(nodesData);
                const jsonStr = formatCompactJSON(sortedData);
                const blob = new Blob([jsonStr], { type: 'application/json' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = 'nodes_with_waypoints.json';
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
                logConsole('JSON downloaded as nodes_with_waypoints.json', 'success');
            } catch (error) {
                logConsole(`Download failed: ${error.message}`, 'error');
            }
        }

        async function loadNodes() {
            const loadBtn = document.getElementById('loadBtn');
            loadBtn.disabled = true;
            
            try {
                logConsole('Starting Waypoint Generator v4.3...', 'highlight');
                
                collision = new CollisionSystem();
                await collision.initialize('https://puzzle-drops.github.io/ScapewatchRC/assets/collision-map.png');
                
                pathfinding = new Pathfinding(collision);
                logConsole('Pathfinding system initialized', 'success');
                
                logConsole('Loading activities data...', 'info');
                await loadActivitiesData();
                
                logConsole('Loading nodes data...', 'info');
                await loadNodesData();
                
                logConsole('Creating node selection interface...', 'info');
                createNodeSelector();
                
                logConsole('Ready! Select nodes and click "Generate Waypoints for Selected"', 'success');
                
            } catch (error) {
                logConsole(`FATAL ERROR: ${error.message}`, 'error');
                logConsole(`Stack trace: ${error.stack}`, 'error');
                loadBtn.disabled = false;
            }
        }

        async function startGeneration() {
            const generateBtn = document.getElementById('generateBtn');
            generateBtn.disabled = true;
            
            if (selectedNodes.size === 0) {
                logConsole('ERROR: No nodes selected!', 'error');
                alert('Please select at least one node to process.');
                generateBtn.disabled = false;
                return;
            }
            
            try {
                logConsole(`Beginning waypoint generation for ${selectedNodes.size} selected nodes...`, 'info');
                await generateWaypoints();
                
            } catch (error) {
                logConsole(`FATAL ERROR: ${error.message}`, 'error');
                logConsole(`Stack trace: ${error.stack}`, 'error');
                generateBtn.disabled = false;
            }
        }

        // Event listeners
        document.getElementById('loadBtn').addEventListener('click', loadNodes);
        document.getElementById('generateBtn').addEventListener('click', startGeneration);
        document.getElementById('selectAllBtn').addEventListener('click', selectAll);
        document.getElementById('deselectAllBtn').addEventListener('click', deselectAll);
        document.getElementById('selectAllBanksBtn').addEventListener('click', () => selectAllByType('bank'));
        document.getElementById('deselectAllBanksBtn').addEventListener('click', () => deselectAllByType('bank'));
        document.getElementById('selectAllSkillsBtn').addEventListener('click', () => {
            document.querySelectorAll('.node-checkbox[data-category^="skill-"]').forEach(checkbox => {
                checkbox.checked = true;
                const nodeId = checkbox.id.replace('node-', '');
                selectedNodes.add(nodeId);
            });
            updateSelectionStats();
        });
        document.getElementById('deselectAllSkillsBtn').addEventListener('click', () => {
            document.querySelectorAll('.node-checkbox[data-category^="skill-"]').forEach(checkbox => {
                checkbox.checked = false;
                const nodeId = checkbox.id.replace('node-', '');
                selectedNodes.delete(nodeId);
            });
            updateSelectionStats();
        });
        document.getElementById('selectAllQuestsBtn').addEventListener('click', () => selectAllByType('quest'));
        document.getElementById('deselectAllQuestsBtn').addEventListener('click', () => deselectAllByType('quest'));
        document.getElementById('exportBtn').addEventListener('click', exportToClipboard);
        document.getElementById('downloadBtn').addEventListener('click', downloadJSON);
        
        // Initial log
        logConsole('Waypoint Generator v4.3 ready', 'highlight');
        logConsole('This tool will:', 'info');
        logConsole('‚Ä¢ Load activities data to categorize nodes by skill', 'info');
        logConsole('‚Ä¢ Let you select nodes organized by type and skill', 'info');
        logConsole('‚Ä¢ Generate paths from selected nodes to nearest banks', 'info');
        logConsole('‚Ä¢ Optionally generate paths between selected banks (toggle checkbox)', 'info');
        logConsole('‚Ä¢ NEW v4.3: Use symmetric path optimization for bank‚Üíbank paths', 'warning');
        logConsole('‚Ä¢ Export nodes sorted by: Banks ‚Üí Multi-skill ‚Üí Skills (A-Z) ‚Üí Quests', 'info');
        logConsole('Click "Load Nodes" to begin', 'success');
    </script>
</body>
</html>
