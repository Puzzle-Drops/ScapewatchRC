<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Node Editor Tool</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: Arial, sans-serif;
            background-color: #1a1a1a;
            color: #fff;
            overflow: hidden;
            display: flex;
            height: 100vh;
        }

        /* Map Container */
        .map-container {
            flex: 1;
            position: relative;
            overflow: hidden;
            background-color: #000;
        }

        #map-canvas {
            position: absolute;
            cursor: crosshair;
            image-rendering: pixelated;
            image-rendering: -moz-crisp-edges;
            image-rendering: crisp-edges;
        }

        /* Controls Panel */
        .controls-panel {
            width: 400px;
            background-color: #2a2a2a;
            padding: 20px;
            overflow-y: auto;
        }

        .panel-section {
            background-color: #333;
            border-radius: 8px;
            padding: 15px;
            margin-bottom: 20px;
        }

        h2 {
            color: #f39c12;
            margin-bottom: 15px;
            font-size: 20px;
        }

        h3 {
            color: #f39c12;
            margin-bottom: 10px;
            font-size: 16px;
        }

        /* Zoom Controls */
        .zoom-controls {
            display: flex;
            gap: 10px;
            margin-bottom: 10px;
        }

        .zoom-controls button {
            flex: 1;
            padding: 10px;
            background-color: #444;
            color: #fff;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 16px;
        }

        .zoom-controls button:hover {
            background-color: #555;
        }

        #zoom-level {
            text-align: center;
            margin-bottom: 10px;
            color: #aaa;
        }

        /* Position Display */
        .position-display {
            background-color: #222;
            padding: 10px;
            border-radius: 4px;
            margin-bottom: 10px;
            font-family: monospace;
            font-size: 14px;
        }

        .position-display.active {
            border: 2px solid #f39c12;
        }

        .position-display.inaccessible {
            border: 2px solid #e74c3c;
            background-color: #3c1f1f;
        }

        .accessibility-status {
            margin-top: 5px;
            font-size: 12px;
            font-weight: bold;
        }

        .accessibility-status.accessible {
            color: #27ae60;
        }

        .accessibility-status.inaccessible {
            color: #e74c3c;
        }

        /* Form Controls */
        .form-group {
            margin-bottom: 15px;
        }

        label {
            display: block;
            margin-bottom: 5px;
            color: #aaa;
            font-size: 14px;
        }

        input[type="text"],
        select {
            width: 100%;
            padding: 8px;
            background-color: #222;
            color: #fff;
            border: 1px solid #444;
            border-radius: 4px;
            font-size: 14px;
        }

        input[type="text"]:focus,
        select:focus {
            outline: none;
            border-color: #f39c12;
        }

        /* Activities Checkboxes */
        .activities-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 8px;
            max-height: 300px;
            overflow-y: auto;
            padding: 10px;
            background-color: #222;
            border-radius: 4px;
        }

        .activity-item {
            display: flex;
            align-items: center;
            gap: 5px;
        }

        .activity-item input[type="checkbox"] {
            width: 16px;
            height: 16px;
            cursor: pointer;
        }

        .activity-item label {
            margin: 0;
            cursor: pointer;
            font-size: 12px;
        }

        /* Buttons */
        .btn {
            width: 100%;
            padding: 12px;
            background-color: #f39c12;
            color: #000;
            border: none;
            border-radius: 4px;
            font-size: 16px;
            font-weight: bold;
            cursor: pointer;
            margin-bottom: 10px;
        }

        .btn:hover {
            background-color: #e67e22;
        }

        .btn-secondary {
            background-color: #3498db;
            color: #fff;
        }

        .btn-secondary:hover {
            background-color: #2980b9;
        }

        .btn-success {
            background-color: #27ae60;
            color: #fff;
        }

        .btn-success:hover {
            background-color: #229954;
        }

        /* Output */
        .output {
            background-color: #222;
            padding: 10px;
            border-radius: 4px;
            font-family: monospace;
            font-size: 12px;
            white-space: pre-wrap;
            word-break: break-all;
            max-height: 200px;
            overflow-y: auto;
        }

        /* Toast Notification */
        .toast {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            background-color: #27ae60;
            color: #fff;
            padding: 15px 30px;
            border-radius: 4px;
            font-size: 16px;
            opacity: 0;
            transition: opacity 0.3s;
            pointer-events: none;
            z-index: 1000;
        }

        .toast.show {
            opacity: 1;
        }

        /* Highlighted Pixel */
        .highlighted-pixel {
            position: absolute;
            border: 2px solid #f39c12;
            pointer-events: none;
            z-index: 11;
            box-shadow: 0 0 10px rgba(243, 156, 18, 0.8),
                       inset 0 0 10px rgba(243, 156, 18, 0.3);
            background-color: rgba(243, 156, 18, 0.2);
        }

        .highlighted-pixel.inaccessible {
            border-color: #e74c3c;
            box-shadow: 0 0 10px rgba(231, 76, 60, 0.8),
                       inset 0 0 10px rgba(231, 76, 60, 0.3);
            background-color: rgba(231, 76, 60, 0.2);
        }

        /* Node info tooltip */
        .node-tooltip {
            position: absolute;
            background-color: rgba(0, 0, 0, 0.95);
            color: #fff;
            padding: 8px 10px;
            border-radius: 4px;
            font-size: 11px;
            line-height: 1.4;
            pointer-events: none;
            z-index: 100;
            display: none;
            max-width: 300px;
            border: 1px solid #444;
        }
        
        .node-tooltip strong {
            color: #f39c12;
        }

        /* Quick Actions */
        .quick-actions {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 5px;
            margin-bottom: 10px;
        }

        .quick-btn {
            padding: 8px;
            background-color: #444;
            color: #fff;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 12px;
        }

        .quick-btn:hover {
            background-color: #555;
        }

        /* Toggle for showing existing nodes */
        .toggle-container {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-bottom: 10px;
        }

        .toggle-container input[type="checkbox"] {
            width: 20px;
            height: 20px;
            cursor: pointer;
        }

        .collision-indicator {
            display: inline-block;
            padding: 3px 8px;
            border-radius: 3px;
            font-size: 11px;
            font-weight: bold;
            margin-left: 10px;
        }

        .collision-indicator.on {
            background-color: #e74c3c;
            color: #fff;
        }

        .collision-indicator.off {
            background-color: #444;
            color: #999;
        }
    </style>
</head>
<body>
    <div class="map-container" id="mapContainer">
        <canvas id="map-canvas"></canvas>
        <div class="highlighted-pixel" id="highlightedPixel" style="display: none;"></div>
        <div class="node-tooltip" id="nodeTooltip"></div>
    </div>

    <div class="controls-panel">
        <div class="panel-section">
            <h2>Map Controls</h2>
            
            <div class="zoom-controls">
                <button onclick="zoomIn()">Zoom In (+)</button>
                <button onclick="zoomOut()">Zoom Out (-)</button>
                <button onclick="resetZoom()">Reset (1)</button>
            </div>
            <div id="zoom-level">Zoom: 1x</div>
            <div style="font-size: 11px; color: #666;">
                Nodes loaded: <span id="nodeCount">0</span> | 
                Activities loaded: <span id="activityCount">0</span> | 
                <span id="collisionStatus" style="color: #e74c3c;">Collision: Loading...</span>
                <span class="collision-indicator" id="collisionIndicator">Collision: OFF</span>
            </div>
            
            <div class="quick-actions">
                <button class="quick-btn" onclick="goToLocation(4395, 1882)">Lumbridge</button>
                <button class="quick-btn" onclick="goToLocation(4370, 1480)">Varrock</button>
                <button class="quick-btn" onclick="goToLocation(4281, 1340)">GE</button>
            </div>
            
            <div class="toggle-container">
                <input type="checkbox" id="showNodes" checked onchange="toggleNodes()">
                <label for="showNodes" style="margin: 0;">Show existing nodes</label>
            </div>
            
            <div class="toggle-container">
                <input type="checkbox" id="showLabels" checked onchange="toggleLabels()">
                <label for="showLabels" style="margin: 0;">Show node labels</label>
            </div>
            
            <div class="toggle-container">
                <input type="checkbox" id="showCollision" onchange="toggleCollision()">
                <label for="showCollision" style="margin: 0;">Show collision map (C key)</label>
            </div>
            
            <div style="font-size: 11px; color: #666; margin: 10px 0; background-color: #222; padding: 8px; border-radius: 4px;">
                <strong>Node Icons:</strong><br>
                üè¶ Banks use bank icon<br>
                üìú Quests use quest icon<br>
                ‚õèÔ∏è Skills show activity icons<br>
                üî¥ Red areas are inaccessible<br>
                Hover over nodes for details
            </div>
            
            <div class="position-display" id="positionDisplay">
                Click on map to select position
                <div class="accessibility-status" id="accessibilityStatus"></div>
            </div>
            
            <div style="font-size: 11px; color: #666; margin: 10px 0;">
                <strong>Controls:</strong><br>
                ‚Ä¢ Left-click: Select pixel & auto-copy position<br>
                ‚Ä¢ Right-click: Select & jump to name field<br>
                ‚Ä¢ Shift+Click or Middle-click: Drag map<br>
                ‚Ä¢ Scroll: Zoom in/out<br>
                ‚Ä¢ +/- keys: Zoom | 1: Reset | G: Focus name field<br>
                ‚Ä¢ C: Toggle collision overlay
            </div>
            
            <button class="btn btn-secondary" onclick="copyPosition()">Copy Position to Clipboard</button>
        </div>

        <div class="panel-section">
            <h2>Create Node</h2>
            
            <div class="form-group">
                <label>Node ID*</label>
                <input type="text" id="nodeId" placeholder="e.g., lumbridge_bank" onkeyup="autoCompleteName()">
            </div>

            <div class="form-group">
                <label>Node Name*</label>
                <input type="text" id="nodeName" placeholder="e.g., Lumbridge Bank">
            </div>

            <div class="form-group">
                <label>Node Type*</label>
                <select id="nodeType" onchange="updateActivityList()">
                    <option value="skill">Skill Node</option>
                    <option value="bank">Bank</option>
                    <option value="quest">Quest</option>
                </select>
            </div>

            <div class="form-group" id="questIdGroup" style="display: none;">
                <label>Quest ID</label>
                <input type="text" id="questId" placeholder="e.g., cooks_assistant">
            </div>

            <div class="form-group" id="activitiesGroup">
                <label>Activities (for skill nodes)</label>
                <div class="quick-actions">
                    <button class="quick-btn" onclick="selectActivities('mining')">All Mining</button>
                    <button class="quick-btn" onclick="selectActivities('fishing')">All Fishing</button>
                    <button class="quick-btn" onclick="selectActivities('woodcutting')">All WC</button>
                    <button class="quick-btn" onclick="clearActivities()">Clear All</button>
                </div>
                <div class="activities-grid" id="activitiesList">
                    <!-- Activities will be populated here -->
                </div>
            </div>

            <button class="btn btn-success" onclick="generateNode()">Generate Node & Copy</button>
            
            <div class="form-group">
                <label>Generated Node JSON:</label>
                <div class="output" id="output"></div>
            </div>
        </div>
    </div>

    <div class="toast" id="toast"></div>

    <script>
        // Canvas and context
        const canvas = document.getElementById('map-canvas');
        const ctx = canvas.getContext('2d');
        const mapContainer = document.getElementById('mapContainer');
        
        // Map state
        let mapImage = null;
        let collisionMapImage = null;
        let collisionCanvas = null;
        let collisionCtx = null;
        let zoom = 1;
        let camera = { x: 4395, y: 1882 }; // Start at Lumbridge
        let isDragging = false;
        let dragStart = { x: 0, y: 0 };
        let selectedPosition = null;
        let showNodes = true;
        let showLabels = true;
        let showCollision = false;
        
        // Data
        let existingNodes = {};
        let activities = {};
        let hoveredNode = null;
        
        // Preloaded skill icons
        const skillIcons = {};
        
        // Load all data
        async function loadData() {
            try {
                // Load map
                mapImage = new Image();
                mapImage.crossOrigin = 'anonymous';
                mapImage.onload = function() {
                    resetView();
                    render();
                    console.log('Map loaded');
                };
                mapImage.src = 'https://puzzle-drops.github.io/Scapewatch/assets/map.png';
                
                // Load collision map
                collisionMapImage = new Image();
                collisionMapImage.crossOrigin = 'anonymous';
                collisionMapImage.onload = function() {
                    // Create off-screen canvas for collision detection
                    collisionCanvas = document.createElement('canvas');
                    collisionCanvas.width = collisionMapImage.width;
                    collisionCanvas.height = collisionMapImage.height;
                    collisionCtx = collisionCanvas.getContext('2d');
                    collisionCtx.drawImage(collisionMapImage, 0, 0);
                    console.log(`Collision map loaded: ${collisionMapImage.width}x${collisionMapImage.height}`);
                    
                    // Update status
                    const collisionStatus = document.getElementById('collisionStatus');
                    if (collisionStatus) {
                        collisionStatus.textContent = 'Collision: Ready';
                        collisionStatus.style.color = '#27ae60';
                    }
                    
                    // Test collision detection at a few points
                    const testPoints = [
                        {x: 4395, y: 1882, name: "Lumbridge"},
                        {x: 4370, y: 1480, name: "Varrock"},
                        {x: 4281, y: 1340, name: "GE"}
                    ];
                    
                    testPoints.forEach(point => {
                        const accessible = isPositionAccessible(point.x, point.y);
                        console.log(`${point.name} (${point.x}, ${point.y}): ${accessible ? 'Accessible' : 'BLOCKED'}`);
                    });
                    
                    render();
                };
                collisionMapImage.onerror = function() {
                    console.error('Failed to load collision map');
                    const collisionStatus = document.getElementById('collisionStatus');
                    if (collisionStatus) {
                        collisionStatus.textContent = 'Collision: Failed';
                        collisionStatus.style.color = '#e74c3c';
                    }
                    showToast('Warning: Collision map failed to load', 'error');
                };
                collisionMapImage.src = 'https://puzzle-drops.github.io/Scapewatch/assets/collision-map.png';
                
                // Load nodes
                const nodesResponse = await fetch('https://puzzle-drops.github.io/Scapewatch/data/nodes.json');
                existingNodes = await nodesResponse.json();
                console.log(`Loaded ${Object.keys(existingNodes).length} existing nodes`);
                document.getElementById('nodeCount').textContent = Object.keys(existingNodes).length;
                
                // Load activities
                const activitiesResponse = await fetch('https://puzzle-drops.github.io/Scapewatch/data/activities.json');
                activities = await activitiesResponse.json();
                console.log(`Loaded ${Object.keys(activities).length} activities`);
                document.getElementById('activityCount').textContent = Object.keys(activities).length;
                
                // Load skill icons
                await loadSkillIcons();
                
                // Populate activities list
                populateActivities();
                
                // Start rendering
                render();
                
                showToast(`Loaded ${Object.keys(existingNodes).length} nodes and ${Object.keys(activities).length} activities!`);
                
            } catch (error) {
                console.error('Error loading data:', error);
                showToast('Error loading data. Some features may not work.', 'error');
            }
        }
        
        // Check if position is accessible
        function isPositionAccessible(x, y) {
            if (!collisionCtx || !collisionMapImage || !collisionMapImage.complete) {
                console.log('Collision map not ready');
                return true; // Default to accessible if no collision map
            }
            
            // Ensure coordinates are within bounds
            if (x < 0 || y < 0 || x >= collisionMapImage.width || y >= collisionMapImage.height) {
                console.log('Position out of bounds:', x, y);
                return false;
            }
            
            // Get pixel data at position
            const pixelData = collisionCtx.getImageData(x, y, 1, 1).data;
            
            // Debug log
            const isAccessible = pixelData[3] === 0;
            if (!isAccessible) {
                console.log(`Position (${x}, ${y}) is blocked - RGBA: ${pixelData[0]}, ${pixelData[1]}, ${pixelData[2]}, ${pixelData[3]}`);
            }
            
            // Check if pixel is transparent (alpha = 0)
            // If there's any color at all (alpha > 0), it's not accessible
            return isAccessible;
        }
        
        // Update accessibility status display
        function updateAccessibilityStatus() {
            if (!selectedPosition) {
                document.getElementById('accessibilityStatus').textContent = '';
                document.getElementById('positionDisplay').classList.remove('inaccessible');
                return;
            }
            
            const accessible = isPositionAccessible(selectedPosition.x, selectedPosition.y);
            const statusElement = document.getElementById('accessibilityStatus');
            const posDisplay = document.getElementById('positionDisplay');
            
            if (accessible) {
                statusElement.textContent = '‚úì Position is accessible';
                statusElement.className = 'accessibility-status accessible';
                posDisplay.classList.remove('inaccessible');
            } else {
                statusElement.textContent = '‚úó Position is NOT accessible (blocked)';
                statusElement.className = 'accessibility-status inaccessible';
                posDisplay.classList.add('inaccessible');
            }
        }
        
        // Toggle collision display
        function toggleCollision() {
            showCollision = document.getElementById('showCollision').checked;
            updateCollisionIndicator();
            render();
        }
        
        // Update collision indicator
        function updateCollisionIndicator() {
            const indicator = document.getElementById('collisionIndicator');
            if (showCollision) {
                indicator.textContent = 'Collision: ON';
                indicator.className = 'collision-indicator on';
            } else {
                indicator.textContent = 'Collision: OFF';
                indicator.className = 'collision-indicator off';
            }
        }
        
        // Load skill icons
        async function loadSkillIcons() {
            const iconNames = [
                'agility', 'attack', 'bank', 'combat', 'construction', 'cooking',
                'crafting', 'defence', 'farming', 'firemaking', 'fishing', 'fletching',
                'herblore', 'hitpoints', 'hunter', 'magic', 'mining', 'prayer',
                'quests', 'ranged', 'runecraft', 'skills', 'slayer', 'smithing',
                'strength', 'thieving', 'woodcutting'
            ];
            
            const loadPromises = iconNames.map(name => {
                return new Promise((resolve) => {
                    const img = new Image();
                    img.crossOrigin = 'anonymous';
                    img.onload = () => {
                        skillIcons[name] = img;
                        resolve();
                    };
                    img.onerror = () => {
                        console.warn(`Failed to load icon: ${name}`);
                        resolve();
                    };
                    img.src = `https://puzzle-drops.github.io/Scapewatch/assets/skills/${name}.png`;
                });
            });
            
            await Promise.all(loadPromises);
            console.log(`Loaded ${Object.keys(skillIcons).length} skill icons`);
        }
        
        // Populate activities list from loaded data
        function populateActivities() {
            const list = document.getElementById('activitiesList');
            list.innerHTML = '';
            
            for (const [id, data] of Object.entries(activities)) {
                const item = document.createElement('div');
                item.className = 'activity-item';
                
                const checkbox = document.createElement('input');
                checkbox.type = 'checkbox';
                checkbox.id = `activity_${id}`;
                checkbox.value = id;
                
                const label = document.createElement('label');
                label.htmlFor = `activity_${id}`;
                label.textContent = data.name;
                label.title = `${data.skill} - Level ${data.requiredLevel}`;
                
                item.appendChild(checkbox);
                item.appendChild(label);
                list.appendChild(item);
            }
        }
        
        // Toggle nodes visibility
        function toggleNodes() {
            showNodes = document.getElementById('showNodes').checked;
            render();
        }
        
        // Toggle labels visibility
        function toggleLabels() {
            showLabels = document.getElementById('showLabels').checked;
            render();
        }
        
        // Auto-complete name based on ID
        function autoCompleteName() {
            const nodeId = document.getElementById('nodeId').value.trim();
            const nameField = document.getElementById('nodeName');
            
            if (nodeId && !nameField.value) {
                // Convert snake_case to Title Case
                const name = nodeId
                    .split('_')
                    .map(word => word.charAt(0).toUpperCase() + word.slice(1))
                    .join(' ');
                nameField.value = name;
            }
        }
        
        // Reset view
        function resetView() {
            if (!mapImage) return;
            
            zoom = 1;
            camera.x = 4395; // Lumbridge
            camera.y = 1882;
            
            canvas.width = mapContainer.clientWidth;
            canvas.height = mapContainer.clientHeight;
        }
        
        // Render
        function render() {
            if (!mapImage || !mapImage.complete) return;
            
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            ctx.save();
            
            // Apply camera transform
            ctx.translate(canvas.width / 2, canvas.height / 2);
            ctx.scale(zoom, zoom);
            ctx.translate(-camera.x, -camera.y);
            
            // Disable smoothing for pixel-perfect rendering
            ctx.imageSmoothingEnabled = false;
            ctx.webkitImageSmoothingEnabled = false;
            ctx.mozImageSmoothingEnabled = false;
            ctx.msImageSmoothingEnabled = false;
            
            // Draw map
            ctx.drawImage(mapImage, 0, 0);
            
            // Draw collision map overlay if enabled
            if (showCollision && collisionMapImage && collisionMapImage.complete) {
                ctx.save();
                ctx.globalAlpha = 0.5;
                ctx.globalCompositeOperation = 'multiply';
                
                // Create a red tinted version
                const tempCanvas = document.createElement('canvas');
                tempCanvas.width = collisionMapImage.width;
                tempCanvas.height = collisionMapImage.height;
                const tempCtx = tempCanvas.getContext('2d');
                
                // Draw collision map
                tempCtx.drawImage(collisionMapImage, 0, 0);
                
                // Apply red tint to non-transparent pixels
                const imageData = tempCtx.getImageData(0, 0, tempCanvas.width, tempCanvas.height);
                const data = imageData.data;
                
                for (let i = 0; i < data.length; i += 4) {
                    if (data[i + 3] > 0) { // If not transparent
                        data[i] = 255;     // Red
                        data[i + 1] = 0;   // Green
                        data[i + 2] = 0;   // Blue
                        data[i + 3] = 128; // Semi-transparent
                    }
                }
                
                tempCtx.putImageData(imageData, 0, 0);
                ctx.drawImage(tempCanvas, 0, 0);
                
                ctx.restore();
            }
            
            // Draw nodes if enabled
            if (showNodes) {
                drawNodes();
            }
            
            ctx.restore();
            
            // Update zoom display
            document.getElementById('zoom-level').textContent = `Zoom: ${Math.round(zoom * 10) / 10}x`;
        }
        
        // Draw nodes on canvas
        function drawNodes() {
            for (const [id, node] of Object.entries(existingNodes)) {
                // Only draw nodes within view
                const screenDist = Math.abs(node.position.x - camera.x) + Math.abs(node.position.y - camera.y);
                if (screenDist > 1500 / zoom) continue;
                
                const x = Math.floor(node.position.x) + 0.5;
                const y = Math.floor(node.position.y) + 0.5;
                
                // Check if node position is accessible
                const accessible = isPositionAccessible(node.position.x, node.position.y);
                
                // Draw icons based on node type
                if (node.type === 'bank') {
                    const bankIcon = skillIcons.bank;
                    if (bankIcon) {
                        ctx.drawImage(bankIcon, x - 2, y - 2, 4, 4);
                    } else {
                        // Fallback yellow square
                        ctx.fillStyle = '#f1c40f';
                        ctx.fillRect(x - 2, y - 2, 4, 4);
                    }
                } else if (node.type === 'quest') {
                    const questIcon = skillIcons.quests;
                    if (questIcon) {
                        ctx.drawImage(questIcon, x - 2, y - 2, 4, 4);
                    } else {
                        // Fallback purple square
                        ctx.fillStyle = '#9b59b6';
                        ctx.fillRect(x - 2, y - 2, 4, 4);
                    }
                } else if (node.type === 'skill' && node.activities) {
                    // Get unique skills from activities
                    const skillSet = new Set();
                    for (const activityId of node.activities) {
                        const activity = activities[activityId];
                        if (activity && activity.skill) {
                            skillSet.add(activity.skill);
                        }
                    }
                    
                    const uniqueSkills = Array.from(skillSet);
                    if (uniqueSkills.length === 0) {
                        // Fallback green square if no activities
                        ctx.fillStyle = '#2ecc71';
                        ctx.fillRect(x - 2, y - 2, 4, 4);
                    } else {
                        const iconSize = 4;
                        const spacing = 0.5;
                        const totalWidth = uniqueSkills.length * iconSize + (uniqueSkills.length - 1) * spacing;
                        const startX = x - totalWidth / 2;
                        
                        // Draw skill icons
                        uniqueSkills.forEach((skill, index) => {
                            const skillIcon = skillIcons[skill];
                            const iconX = startX + index * (iconSize + spacing);
                            if (skillIcon) {
                                ctx.drawImage(skillIcon, iconX, y - 2, iconSize, iconSize);
                            } else {
                                // Fallback colored square
                                ctx.fillStyle = '#2ecc71';
                                ctx.fillRect(iconX, y - 2, iconSize, iconSize);
                            }
                        });
                    }
                }
                
                // Draw inaccessible indicator
                if (!accessible) {
                    ctx.strokeStyle = '#e74c3c';
                    ctx.lineWidth = 0.5;
                    ctx.strokeRect(x - 3, y - 3, 6, 6);
                }
                
                // Draw node name if labels are enabled
                if (showLabels) {
                    ctx.font = '2px Arial';
                    ctx.fillStyle = accessible ? '#fff' : '#ff9999';
                    ctx.strokeStyle = '#000';
                    ctx.lineWidth = 0.25;
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'bottom';
                    ctx.strokeText(node.name, x, y - 5);
                    ctx.fillText(node.name, x, y - 5);
                }
            }
        }
        
        // Convert screen to world coordinates
        function screenToWorld(screenX, screenY) {
            const rect = canvas.getBoundingClientRect();
            const x = screenX - rect.left;
            const y = screenY - rect.top;
            
            const worldX = (x - canvas.width / 2) / zoom + camera.x;
            const worldY = (y - canvas.height / 2) / zoom + camera.y;
            
            return {
                x: Math.floor(worldX),
                y: Math.floor(worldY)
            };
        }
        
        // Convert world to screen coordinates
        function worldToScreen(worldX, worldY) {
            const x = (worldX - camera.x) * zoom + canvas.width / 2;
            const y = (worldY - camera.y) * zoom + canvas.height / 2;
            return { x, y };
        }
        
        // Zoom controls
        function zoomIn() {
            zoom = Math.min(zoom * 1.5, 50);
            render();
            updateHighlight();
        }
        
        function zoomOut() {
            zoom = Math.max(zoom / 1.5, 0.5);
            render();
            updateHighlight();
        }
        
        function resetZoom() {
            zoom = 1;
            render();
            updateHighlight();
        }
        
        // Go to location
        function goToLocation(x, y) {
            camera.x = x;
            camera.y = y;
            zoom = 5;
            render();
            updateHighlight();
        }
        
        // Update highlighted pixel position
        function updateHighlight() {
            if (!selectedPosition) {
                document.getElementById('highlightedPixel').style.display = 'none';
                return;
            }
            
            const screen = worldToScreen(selectedPosition.x + 0.5, selectedPosition.y + 0.5);
            const pixel = document.getElementById('highlightedPixel');
            
            const pixelSize = Math.max(zoom, 10);
            
            pixel.style.display = 'block';
            pixel.style.left = `${screen.x - pixelSize/2}px`;
            pixel.style.top = `${screen.y - pixelSize/2}px`;
            pixel.style.width = `${pixelSize}px`;
            pixel.style.height = `${pixelSize}px`;
            
            // Check accessibility and update color immediately
            const accessible = isPositionAccessible(selectedPosition.x, selectedPosition.y);
            if (accessible) {
                pixel.classList.remove('inaccessible');
            } else {
                pixel.classList.add('inaccessible');
            }
            
            updateAccessibilityStatus();
        }
        
        // Mouse events
        canvas.addEventListener('contextmenu', (e) => {
            e.preventDefault();
            return false;
        });
        
        canvas.addEventListener('mousedown', (e) => {
            if (e.button === 2) { // Right click
                e.preventDefault();
                const world = screenToWorld(e.clientX, e.clientY);
                selectedPosition = world;
                
                const display = document.getElementById('positionDisplay');
                display.textContent = `Position: { "x": ${world.x}, "y": ${world.y} }`;
                display.classList.add('active');
                
                updateHighlight();
                
                // Check accessibility and show appropriate toast
                const accessible = isPositionAccessible(world.x, world.y);
                console.log(`Right-clicked position (${world.x}, ${world.y}): ${accessible ? 'Accessible' : 'BLOCKED'}`);
                if (accessible) {
                    showToast('Position selected! Enter node ID.', 'success');
                } else {
                    showToast('Position selected but is BLOCKED! Enter node ID.', 'error');
                }
                
                document.getElementById('nodeId').focus();
                document.getElementById('nodeId').select();
            } else if (e.button === 0 && !e.shiftKey) { // Left click
                const world = screenToWorld(e.clientX, e.clientY);
                selectedPosition = world;
                
                const display = document.getElementById('positionDisplay');
                display.textContent = `Position: { "x": ${world.x}, "y": ${world.y} }`;
                display.classList.add('active');
                
                updateHighlight();
                
                // Check accessibility for toast message
                const accessible = isPositionAccessible(world.x, world.y);
                console.log(`Left-clicked position (${world.x}, ${world.y}): ${accessible ? 'Accessible' : 'BLOCKED'}`);
                if (!accessible) {
                    showToast('Warning: Position is blocked!', 'error');
                }
                
                copyPosition(true);
            } else if (e.button === 0 && e.shiftKey || e.button === 1) { // Drag
                isDragging = true;
                dragStart.x = e.clientX;
                dragStart.y = e.clientY;
                canvas.style.cursor = 'grabbing';
            }
        });
        
        canvas.addEventListener('mousemove', (e) => {
            if (isDragging) {
                const dx = (e.clientX - dragStart.x) / zoom;
                const dy = (e.clientY - dragStart.y) / zoom;
                
                camera.x -= dx;
                camera.y -= dy;
                
                dragStart.x = e.clientX;
                dragStart.y = e.clientY;
                
                render();
                updateHighlight();
            } else {
                // Check for node hover
                const world = screenToWorld(e.clientX, e.clientY);
                checkNodeHover(world.x, world.y, e.clientX, e.clientY);
            }
        });
        
        // Check if hovering over a node
        function checkNodeHover(worldX, worldY, screenX, screenY) {
            let foundNode = null;
            let foundId = null;
            
            for (const [id, node] of Object.entries(existingNodes)) {
                const dist = Math.sqrt(
                    Math.pow(worldX - node.position.x, 2) + 
                    Math.pow(worldY - node.position.y, 2)
                );
                
                if (dist <= 3) { // Within 3 pixels
                    foundNode = node;
                    foundId = id;
                    break;
                }
            }
            
            const tooltip = document.getElementById('nodeTooltip');
            
            if (foundNode) {
                // Build tooltip text
                let tooltipHTML = `<strong>${foundNode.name}</strong><br>`;
                tooltipHTML += `ID: ${foundId}<br>`;
                tooltipHTML += `Type: ${foundNode.type}<br>`;
                tooltipHTML += `Pos: ${foundNode.position.x}, ${foundNode.position.y}`;
                
                // Check accessibility
                const accessible = isPositionAccessible(foundNode.position.x, foundNode.position.y);
                if (!accessible) {
                    tooltipHTML += `<br><span style="color: #e74c3c;">‚ö† Inaccessible</span>`;
                }
                
                if (foundNode.activities && foundNode.activities.length > 0) {
                    tooltipHTML += `<br>Activities: ${foundNode.activities.length}`;
                    // Show first few activities
                    const activityNames = foundNode.activities.slice(0, 3).map(actId => {
                        const act = activities[actId];
                        return act ? act.name : actId;
                    });
                    tooltipHTML += `<br>${activityNames.join(', ')}`;
                    if (foundNode.activities.length > 3) {
                        tooltipHTML += ` +${foundNode.activities.length - 3} more`;
                    }
                }
                
                if (foundNode.questId) {
                    tooltipHTML += `<br>Quest: ${foundNode.questId}`;
                }
                
                tooltip.innerHTML = tooltipHTML;
                tooltip.style.display = 'block';
                tooltip.style.left = `${screenX + 10}px`;
                tooltip.style.top = `${screenY - 30}px`;
                hoveredNode = foundNode;
            } else if (hoveredNode) {
                // Hide tooltip
                tooltip.style.display = 'none';
                hoveredNode = null;
            }
        }
        
        canvas.addEventListener('mouseup', () => {
            isDragging = false;
            canvas.style.cursor = 'crosshair';
        });
        
        canvas.addEventListener('wheel', (e) => {
            e.preventDefault();
            
            const delta = e.deltaY > 0 ? 0.9 : 1.1;
            const newZoom = Math.max(0.5, Math.min(50, zoom * delta));
            
            const world = screenToWorld(e.clientX, e.clientY);
            zoom = newZoom;
            const newWorld = screenToWorld(e.clientX, e.clientY);
            
            camera.x += world.x - newWorld.x;
            camera.y += world.y - newWorld.y;
            
            render();
            updateHighlight();
        });
        
        // Copy position
        function copyPosition(silent = false) {
            if (!selectedPosition) {
                if (!silent) showToast('No position selected!', 'error');
                return;
            }
            
            const positionText = `"x": ${selectedPosition.x}, "y": ${selectedPosition.y}`;
            navigator.clipboard.writeText(positionText);
            
            if (!silent) {
                const accessible = isPositionAccessible(selectedPosition.x, selectedPosition.y);
                if (accessible) {
                    showToast('Position copied to clipboard!');
                } else {
                    showToast('Position copied (Warning: blocked location!)', 'error');
                }
            }
        }
        
        // Update form based on node type
        function updateActivityList() {
            const nodeType = document.getElementById('nodeType').value;
            document.getElementById('activitiesGroup').style.display = nodeType === 'skill' ? 'block' : 'none';
            document.getElementById('questIdGroup').style.display = nodeType === 'quest' ? 'block' : 'none';
        }
        
        // Select activities by type
        function selectActivities(type) {
            const checkboxes = document.querySelectorAll('.activity-item input[type="checkbox"]');
            checkboxes.forEach(cb => {
                const activityData = activities[cb.value];
                if (activityData) {
                    if (type === 'mining' && activityData.skill === 'mining') {
                        cb.checked = true;
                    } else if (type === 'fishing' && activityData.skill === 'fishing') {
                        cb.checked = true;
                    } else if (type === 'woodcutting' && activityData.skill === 'woodcutting') {
                        cb.checked = true;
                    }
                }
            });
        }
        
        // Clear all activities
        function clearActivities() {
            const checkboxes = document.querySelectorAll('.activity-item input[type="checkbox"]');
            checkboxes.forEach(cb => cb.checked = false);
        }
        
        // Generate node
        function generateNode() {
            const nodeId = document.getElementById('nodeId').value.trim();
            const nodeName = document.getElementById('nodeName').value.trim();
            
            if (!nodeId) {
                showToast('Please enter a node ID!', 'error');
                return;
            }
            
            if (!nodeName) {
                showToast('Please enter a node name!', 'error');
                return;
            }
            
            if (!selectedPosition) {
                showToast('Please select a position on the map!', 'error');
                return;
            }
            
            // Check if position is accessible
            const accessible = isPositionAccessible(selectedPosition.x, selectedPosition.y);
            if (!accessible) {
                if (!confirm('Warning: This position is NOT accessible (blocked by collision). Do you still want to create the node?')) {
                    return;
                }
            }
            
            // Build node object
            const node = {
                id: nodeId,
                name: nodeName,
                type: document.getElementById('nodeType').value,
                position: {
                    x: selectedPosition.x,
                    y: selectedPosition.y
                }
            };
            
            // Add type-specific properties
            if (node.type === 'skill') {
                const selectedActivities = [];
                const checkboxes = document.querySelectorAll('.activity-item input[type="checkbox"]:checked');
                checkboxes.forEach(cb => selectedActivities.push(cb.value));
                
                if (selectedActivities.length > 0) {
                    node.activities = selectedActivities;
                }
            } else if (node.type === 'quest') {
                const questId = document.getElementById('questId').value.trim();
                if (questId) {
                    node.questId = questId;
                }
            }
            
            // Format JSON
            const jsonText = `    "${nodeId}": ${JSON.stringify(node, null, 8).split('\n').join('\n    ')}`;
            
            // Display and copy
            document.getElementById('output').textContent = jsonText;
            navigator.clipboard.writeText(jsonText);
            
            showToast('Node copied to clipboard!' + (accessible ? '' : ' (Warning: inaccessible position)'));
            
            // Clear form for next node
            document.getElementById('nodeName').value = '';
            document.getElementById('nodeId').value = '';
            document.getElementById('questId').value = '';
            clearActivities();
        }
        
        // Show toast notification
        function showToast(message, type = 'success') {
            const toast = document.getElementById('toast');
            toast.textContent = message;
            toast.style.backgroundColor = type === 'error' ? '#e74c3c' : '#27ae60';
            toast.classList.add('show');
            
            setTimeout(() => {
                toast.classList.remove('show');
            }, 3000);
        }
        
        // Keyboard shortcuts
        document.addEventListener('keydown', (e) => {
            if (e.target.tagName === 'INPUT' || e.target.tagName === 'SELECT') {
                if (e.key === 'Enter' && e.ctrlKey) {
                    generateNode();
                }
                return;
            }
            
            if (e.key === '+' || e.key === '=') {
                zoomIn();
            } else if (e.key === '-') {
                zoomOut();
            } else if (e.key === '1') {
                resetZoom();
            } else if (e.key === 'c' || e.key === 'C') {
                if (!e.ctrlKey) { // Make sure it's not Ctrl+C
                    e.preventDefault();
                    const checkbox = document.getElementById('showCollision');
                    checkbox.checked = !checkbox.checked;
                    toggleCollision();
                }
            } else if (e.key === 'g' || e.key === 'G') {
                document.getElementById('nodeId').focus();
                document.getElementById('nodeId').select();
            }
        });
        
        // Resize handler
        window.addEventListener('resize', () => {
            canvas.width = mapContainer.clientWidth;
            canvas.height = mapContainer.clientHeight;
            render();
            updateHighlight();
        });
        
        // Initialize
        window.addEventListener('DOMContentLoaded', () => {
            canvas.width = mapContainer.clientWidth;
            canvas.height = mapContainer.clientHeight;
            loadData();
            updateActivityList();
            updateCollisionIndicator();
        });
    </script>
</body>
</html>
